<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redmine 工時助手</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap');

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
        }

        .timer-card {
            transition: all 0.2s;
        }

        .timer-card.active {
            border-left: 5px solid #10b981;
            background-color: #ecfdf5;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal-overlay {
            animation: fadeIn 0.2s ease-out forwards;
        }

        .modal-content {
            animation: scaleIn 0.2s ease-out forwards;
        }

        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <!-- Firebase Logic Module -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, initializeFirestore } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        let app, auth, db;
        let isFirebaseAvailable = false;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const LS_CONFIG_KEY = 'redmine_firebase_config_v2';

        // Initialization Logic
        try {
            let configToUse = null;
            // 1. Try LocalStorage (User Setting)
            const localConfigStr = localStorage.getItem(LS_CONFIG_KEY);
            if (localConfigStr) {
                try {
                    configToUse = JSON.parse(localConfigStr);
                    console.log("Loaded Firebase config from LocalStorage");
                } catch (e) {
                    console.error("Invalid JSON in LocalStorage", e);
                }
            }
            // 2. Try Environment Variable (Fallback)
            else if (typeof __firebase_config !== 'undefined') {
                configToUse = JSON.parse(__firebase_config);
                console.log("Loaded Firebase config from Environment");
            }

            if (configToUse) {
                app = initializeApp(configToUse);
                auth = getAuth(app);
                // Force Long Polling for stability
                db = initializeFirestore(app, {
                    experimentalForceLongPolling: true,
                    useFetchStreams: false,
                });
                isFirebaseAvailable = true;
            } else {
                console.warn("未偵測到 Firebase 設定，雲端同步功能將無法使用 (離線模式)。");
            }
        } catch (e) {
            console.error("Firebase init failed:", e);
        }

        // Auth Singleton
        let authReadyPromise = new Promise((resolve, reject) => {
            if (!isFirebaseAvailable) {
                return resolve(null);
            }
            const unsubscribe = onAuthStateChanged(auth, (user) => {
                if (user) {
                    unsubscribe();
                    resolve(user);
                } else {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        signInWithCustomToken(auth, __initial_auth_token).catch(e => console.error("Token sign-in failed", e));
                    } else {
                        signInAnonymously(auth).catch(e => console.error("Anon sign-in failed", e));
                    }
                }
            });
        });

        // Retry Helper
        const retryOperation = async (operation, maxRetries = 2, delay = 1000) => {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    // Quick fail on permission denied
                    if (error.code === 'permission-denied') throw error;

                    if (i < maxRetries - 1 && (error.code === 'unavailable' || error.message.includes('offline') || error.message.includes('network'))) {
                        console.warn(`Firestore unavailable, retrying... (${i + 1})`);
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    } else {
                        throw error;
                    }
                }
            }
        };

        window.CloudService = {
            isAvailable: () => isFirebaseAvailable,
            saveData: async (accessKey, data, customUid = null) => {
                if (!isFirebaseAvailable) throw new Error("OFFLINE_MODE (No Config)");
                const user = await authReadyPromise;
                if (!user) throw new Error("認證失敗 (Auth Failed)");
                try {
                    await retryOperation(async () => {
                        const targetUid = customUid || user.uid;
                        // Use a simpler path for standalone usage (when __app_id is not injected)
                        const collectionPath = typeof __app_id !== 'undefined'
                            ? `artifacts/${__app_id}/users/${targetUid}/redmine_timer_v3`
                            : `users/${targetUid}/redmine_timer_v3`;

                        const docRef = doc(db, collectionPath, accessKey);
                        await setDoc(docRef, { ...data, updatedAt: new Date().toISOString(), savedBy: user.uid }, { merge: true });
                    });
                } catch (e) {
                    if (e.code === 'permission-denied') throw new Error("PERMISSION_DENIED");
                    if (e.code === 'unavailable' || e.message.includes('offline')) throw new Error("OFFLINE_MODE");
                    throw e;
                }
            },
            loadData: async (accessKey, customUid = null) => {
                if (!isFirebaseAvailable) throw new Error("OFFLINE_MODE (No Config)");
                const user = await authReadyPromise;
                if (!user) throw new Error("認證失敗 (Auth Failed)");
                try {
                    return await retryOperation(async () => {
                        const targetUid = customUid || user.uid;
                        const collectionPath = typeof __app_id !== 'undefined'
                            ? `artifacts/${__app_id}/users/${targetUid}/redmine_timer_v3`
                            : `users/${targetUid}/redmine_timer_v3`;

                        const docRef = doc(db, collectionPath, accessKey);
                        const docSnap = await getDoc(docRef);
                        if (docSnap.exists()) return docSnap.data();
                        return null;
                    });
                } catch (e) {
                    if (e.code === 'permission-denied') throw new Error("PERMISSION_DENIED");
                    if (e.code === 'unavailable' || e.message.includes('offline')) throw new Error("OFFLINE_MODE");
                    throw e;
                }
            }
        };
    </script>

    <!-- React App -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useLayoutEffect } = React;

        const FIXED_ACCESS_KEY = 'redmine_diary_report';
        const LS_CONFIG_KEY = 'redmine_firebase_config_v2';

        // --- Helper: Strip HTML ---
        const stripHtml = (html) => {
            if (!html) return "";
            let text = html.replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/p>/gi, '\n')
                .replace(/<\/li>/gi, '\n')
                .replace(/<\/div>/gi, '\n');
            const temp = document.createElement("div");
            temp.innerHTML = text;
            text = temp.textContent || temp.innerText || "";
            return text.replace(/(\r\n|\n|\r){3,}/g, '\n\n').trim();
        };

        // --- Helper: Safe JSON Parse ---
        const safeFetchJson = async (response) => {
            const text = await response.text();
            try {
                return JSON.parse(text);
            } catch (e) {
                if (text.trim().toLowerCase().startsWith('<!doctype') || text.trim().toLowerCase().startsWith('<html')) {
                    throw new Error("伺服器回傳了 HTML 頁面而非 JSON，請檢查 Redmine 網址、API Key 或 Proxy 設定。");
                }
                throw new Error(`JSON 解析失敗: ${text.substring(0, 50)}...`);
            }
        };

        // --- Icon Component ---
        const Icon = ({ name, size = 20, className = "" }) => {
            const elementRef = useRef(null);
            useEffect(() => {
                if (typeof lucide === 'undefined') return;
                const iconKey = name.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');
                const iconDef = lucide.icons[iconKey];
                if (iconDef && elementRef.current) {
                    try {
                        const svg = lucide.createElement(iconDef);
                        svg.setAttribute('width', size); svg.setAttribute('height', size); svg.setAttribute('stroke-width', 2);
                        if (className) svg.setAttribute('class', className);
                        elementRef.current.innerHTML = ''; elementRef.current.appendChild(svg);
                    } catch (err) { }
                }
            }, [name, size, className]);
            return <span ref={elementRef} className="inline-flex items-center justify-center" style={{ width: size, height: size }}></span>;
        };

        // --- Modal ---
        const Modal = ({ config, onClose }) => {
            if (!config.isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] modal-overlay p-4">
                    <div className="bg-white rounded-xl shadow-2xl max-w-lg w-full p-6 modal-content border border-gray-100 max-h-[90vh] overflow-y-auto overflow-x-hidden">
                        <div className="flex items-center gap-3 mb-4 text-gray-800">
                            {config.type === 'confirm' ? <div className="p-2 bg-yellow-100 text-yellow-600 rounded-full"><Icon name="alert-triangle" size={24} /></div> : <div className="p-2 bg-blue-100 text-blue-600 rounded-full"><Icon name="info" size={24} /></div>}
                            <h3 className="text-lg font-bold">{config.title || '提示'}</h3>
                        </div>
                        {config.renderContent ? config.renderContent() : (
                            <p className="text-gray-600 mb-8 ml-1 whitespace-pre-wrap break-words break-all text-sm leading-relaxed">{config.message}</p>
                        )}
                        <div className="flex justify-end gap-3 mt-4">
                            {config.type === 'confirm' && <button onClick={onClose} className="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded-lg">取消</button>}
                            <button onClick={() => { if (config.onConfirm) config.onConfirm(); onClose(); }} className={`px-5 py-2 rounded-lg text-white font-bold shadow-sm active:scale-95 ${config.type === 'confirm' ? 'bg-red-600 hover:bg-red-700' : 'bg-gray-800 hover:bg-gray-700'}`}>{config.confirmText || '確定'}</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Settings Modal ---
        const SettingsModal = ({ isOpen, onClose, options, setOptions, workSettings, setWorkSettings, staticData, setStaticData, redmineApiConfig, setRedmineApiConfig, userName, setUserName, setRedmineUserId, redmineUserId, syncStatus, lastSyncTime, onManualLoad, onManualSave, showAlert, onShowRulesHelp }) => {
            const [localWork, setLocalWork] = useState(workSettings);
            const [localApiConfig, setLocalApiConfig] = useState(redmineApiConfig);
            const [localUserName, setLocalUserName] = useState(userName);
            const [isFetching, setIsFetching] = useState({ projects: false, trackers: false, activities: false, user: false });

            const [firebaseConfigStr, setFirebaseConfigStr] = useState('');
            const [projectsJson, setProjectsJson] = useState('');
            const [trackersJson, setTrackersJson] = useState('');
            const [activitiesJson, setActivitiesJson] = useState('');

            useEffect(() => {
                if (isOpen) {
                    setLocalWork(workSettings);
                    setLocalApiConfig(redmineApiConfig);
                    setLocalUserName(userName);

                    const storedConfig = localStorage.getItem(LS_CONFIG_KEY);
                    if (storedConfig) {
                        setFirebaseConfigStr(storedConfig);
                    }
                }
            }, [isOpen, workSettings, redmineApiConfig, userName]);

            useEffect(() => {
                if (isOpen) {
                    setProjectsJson(staticData.projects && staticData.projects.length ? JSON.stringify(staticData.projects, null, 2) : '');
                    setTrackersJson(staticData.trackers && staticData.trackers.length ? JSON.stringify(staticData.trackers, null, 2) : '');
                    setActivitiesJson(staticData.activities && staticData.activities.length ? JSON.stringify(staticData.activities, null, 2) : '');
                }
            }, [isOpen, staticData]);

            // Helper to prepare URL - 使用後端代理
            // apiBaseUrl 可設定為後端 API 的基礎 URL，例如 https://api.example.com
            // 空字串表示同源 (開發模式)
            const prepareFetchUrl = (rawUrl) => {
                let url = rawUrl.trim();
                let key = localApiConfig.apiKey ? localApiConfig.apiKey.trim() : '';

                // 替換密鑰佔位符 (僅用於顯示/除錯，後端會使用 session 中的 key)
                if (key) {
                    url = url.replace(/\{(?:\s*key|api_?key|密鑰)\s*\}/gi, key);
                }

                // 提取路徑部分 (去除 host)
                let path = url;
                if (localApiConfig.host) {
                    let host = localApiConfig.host.trim().replace(/\/$/, '');
                    if (!/^https?:\/\//i.test(host)) host = 'https://' + host;
                    // 如果 url 是完整 URL，提取路徑
                    if (url.startsWith(host)) {
                        path = url.substring(host.length);
                    }
                }

                // 如果 url 不是以 / 開頭，且不是完整 URL，則視為相對路徑
                if (!path.startsWith('/') && !/^https?:\/\//i.test(path)) {
                    path = '/' + path;
                }

                // 如果是完整 URL (非本機 host)，提取路徑部分
                if (/^https?:\/\//i.test(path)) {
                    try {
                        const urlObj = new URL(path);
                        path = urlObj.pathname + urlObj.search;
                    } catch (e) {
                        // 解析失敗，保持原樣
                    }
                }

                // 使用後端代理，支援可配置的 API 基礎 URL
                const apiBase = localApiConfig.apiBaseUrl ? localApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                return `${apiBase}/api/proxy?path=${encodeURIComponent(path)}`;
            };

            const parseRedmineJson = (input, key) => {
                if (!input || !input.trim()) return [];
                const cleanInput = input.trim();
                let result = [];
                try {
                    const parsed = JSON.parse(cleanInput);
                    if (Array.isArray(parsed)) {
                        result = parsed;
                    } else if (parsed[key] && Array.isArray(parsed[key])) {
                        result = parsed[key];
                    } else if (parsed.project && parsed.project[key] && Array.isArray(parsed.project[key])) {
                        result = parsed.project[key];
                    } else if (parsed.id && parsed.name) {
                        result = [parsed];
                    }
                } catch (e) {
                    try {
                        const arrayStr = '[' + cleanInput.replace(/}\s*[\r\n]*\s*{/g, '},{') + ']';
                        const parsedArr = JSON.parse(arrayStr);
                        parsedArr.forEach(obj => {
                            if (obj[key] && Array.isArray(obj[key])) result = result.concat(obj[key]);
                            else if (obj.project && obj.project[key] && Array.isArray(obj.project[key])) result = result.concat(obj.project[key]);
                            else if (Array.isArray(obj)) result = result.concat(obj);
                        });
                    } catch (e2) { throw new Error(`無法解析 JSON (${key})`); }
                }
                return result;
            };

            const fetchAndParse = async (urlsStr, type, silent = false) => {
                if (!urlsStr || !urlsStr.trim()) return [];
                const urls = urlsStr.split('\n').filter(u => u.trim());
                let allResults = [];

                setIsFetching(prev => ({ ...prev, [type]: true }));

                try {
                    for (let url of urls) {
                        const fetchUrl = prepareFetchUrl(url);
                        // 不需要附加 API Key 標頭，後端代理會處理
                        const headers = {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        };

                        console.log(`[RedmineFetch] Fetching via proxy: ${fetchUrl}`);

                        const res = await fetch(fetchUrl, { headers, credentials: 'include' });
                        if (!res.ok) {
                            const errorText = await res.text();
                            throw new Error(`Fetch failed: ${res.status} - ${errorText || res.statusText}`);
                        }

                        const data = await safeFetchJson(res);

                        if (type === 'projects') {
                            if (data.projects) allResults = allResults.concat(data.projects);
                            else if (Array.isArray(data)) allResults = allResults.concat(data);
                        }
                        else if (type === 'trackers') {
                            if (data.trackers) allResults = allResults.concat(data.trackers);
                            else if (data.project && data.project.trackers) allResults = allResults.concat(data.project.trackers);
                        }
                        else if (type === 'activities') {
                            if (data.time_entry_activities) allResults = allResults.concat(data.time_entry_activities);
                        }
                    }
                    if (!silent) showAlert("成功", `成功載入 ${allResults.length} 筆資料`);
                    return allResults.map(item => ({ id: item.id, name: item.name }));
                } catch (e) {
                    if (!silent) {
                        showAlert("載入失敗", `${e.message}\n\n請確認後端伺服器已啟動，且已正確設定 Redmine 連線資訊。`);
                    }
                    console.error(e);
                    return null;
                } finally {
                    setIsFetching(prev => ({ ...prev, [type]: false }));
                }
            };

            const handleFetchProjects = async (silent = false) => {
                const results = await fetchAndParse(localApiConfig.projectsApiUrl || '', 'projects', silent);
                if (results) setStaticData(prev => ({ ...prev, projects: results }));
            };

            const handleFetchTrackers = async (silent = false) => {
                const results = await fetchAndParse(localApiConfig.trackersApiUrl || '', 'trackers', silent);
                if (results) setStaticData(prev => ({ ...prev, trackers: results }));
            };

            const handleFetchActivities = async (silent = false) => {
                const results = await fetchAndParse(localApiConfig.activitiesApiUrl || '', 'activities', silent);
                if (results) setStaticData(prev => ({ ...prev, activities: results }));
            };

            // Modified to return the name on success - 使用後端代理
            const handleFetchUser = async (silent = false) => {
                if (!localApiConfig.host || !localApiConfig.apiKey) {
                    if (!silent) showAlert("錯誤", "請先設定 Redmine 網址與 API Key");
                    return null;
                }

                setIsFetching(prev => ({ ...prev, user: true }));

                try {
                    const fetchUrl = prepareFetchUrl('/users/current.json');
                    // 不需要附加 API Key 標頭，後端代理會處理
                    const headers = {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    };

                    console.log(`[RedmineFetch] Fetching User via proxy: ${fetchUrl}`);

                    const res = await fetch(fetchUrl, { headers, credentials: 'include' });
                    if (!res.ok) {
                        const errorText = await res.text();
                        throw new Error(`Fetch failed: ${res.status} - ${errorText || res.statusText}`);
                    }

                    const data = await safeFetchJson(res);

                    if (data.user) {
                        setRedmineUserId(data.user.id);
                        const l = (data.user.lastname || '').trim();
                        const f = (data.user.firstname || '').trim();
                        let name = '';

                        const hasNonAscii = (str) => /[^\x00-\x7F]/.test(str);

                        if (!l) name = f;
                        else if (!f) name = l;
                        else if (l.includes(f)) name = l;
                        else if (f.includes(l)) name = f;
                        else if (hasNonAscii(l) && !hasNonAscii(f)) name = l;
                        else if (hasNonAscii(f) && !hasNonAscii(l)) name = f;
                        else name = `${l}${f}`;

                        setLocalUserName(name);
                        if (!silent) showAlert("成功", `已取得用戶名稱: ${name}`);
                        return name; // Return name for handleSaveAndClose
                    } else {
                        throw new Error("API 回傳格式不如預期 (找不到 user 欄位)");
                    }
                } catch (e) {
                    if (!silent) {
                        showAlert("失敗", `無法取得用戶資訊: ${e.message}\n\n請確認後端伺服器已啟動且已正確設定連線資訊。`);
                    }
                    console.error(e);
                } finally {
                    setIsFetching(prev => ({ ...prev, user: false }));
                }
                return null;
            };

            const handleAutoLoad = async () => {
                if (!localApiConfig.host || !localApiConfig.apiKey) return;

                // 先透過後端建立 session，這樣後續的 /api/proxy 呼叫才能使用 session 中的認證資訊
                const apiBase = localApiConfig.apiBaseUrl ? localApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                try {
                    const loginRes = await fetch(`${apiBase}/api/auth/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            host: localApiConfig.host,
                            apiKey: localApiConfig.apiKey,
                            geminiApiKey: localApiConfig.geminiApiKey || '',
                            firebaseConfig: null,
                            corsProxy: localApiConfig.corsProxy || ''
                        }),
                        credentials: 'include'
                    });
                    if (!loginRes.ok) {
                        const errorText = await loginRes.text();
                        throw new Error(`Session 建立失敗: ${loginRes.status} - ${errorText}`);
                    }
                    console.log('[RedmineAutoLoad] Session established successfully');
                } catch (e) {
                    console.error('[RedmineAutoLoad] Failed to establish session:', e);
                    showAlert("連線失敗", `無法連接到後端伺服器: ${e.message}\n\n請確認後端伺服器已啟動 (npm start)。`);
                    return;
                }

                setIsFetching({ projects: true, trackers: true, activities: true, user: true });

                await handleFetchUser(true);

                const defaultProjectsUrl = '/projects.json?key={密鑰}&limit=100&offset=0\n/projects.json?key={密鑰}&limit=100&offset=100\n/projects.json?key={密鑰}&limit=100&offset=200';
                const defaultTrackersUrl = '/projects/old_web.json?include=trackers&key={密鑰}';
                const defaultActivitiesUrl = '/enumerations/time_entry_activities.json?key={密鑰}';

                const p1 = fetchAndParse(localApiConfig.projectsApiUrl || defaultProjectsUrl, 'projects', true).then(res => res && setStaticData(prev => ({ ...prev, projects: res })));
                const p2 = fetchAndParse(localApiConfig.trackersApiUrl || defaultTrackersUrl, 'trackers', true).then(res => res && setStaticData(prev => ({ ...prev, trackers: res })));
                const p3 = fetchAndParse(localApiConfig.activitiesApiUrl || defaultActivitiesUrl, 'activities', true).then(res => res && setStaticData(prev => ({ ...prev, activities: res })));

                await Promise.all([p1, p2, p3]);

                setIsFetching({ projects: false, trackers: false, activities: false, user: false });

                showAlert("自動載入完成", "已根據 API Key 自動更新用戶與下拉選單資料。");
            };

            const getAndApplySettings = (overrideUserName = null) => {
                let newProjects = staticData.projects;
                let newTrackers = staticData.trackers;
                let newActivities = staticData.activities;

                if (projectsJson && projectsJson.trim().startsWith('{')) {
                    try { newProjects = parseRedmineJson(projectsJson, 'projects').map(p => ({ id: p.id, name: p.name })); } catch (e) { showAlert("設定錯誤", e.message); return null; }
                }
                if (trackersJson && trackersJson.trim().startsWith('{')) {
                    try { newTrackers = parseRedmineJson(trackersJson, 'trackers').map(t => ({ id: t.id, name: t.name })); } catch (e) { showAlert("設定錯誤", e.message); return null; }
                }
                if (activitiesJson && activitiesJson.trim().startsWith('{')) {
                    try { newActivities = parseRedmineJson(activitiesJson, 'time_entry_activities').map(a => ({ id: a.id, name: a.name })); } catch (e) { showAlert("設定錯誤", e.message); return null; }
                }

                const newStaticData = {
                    projects: newProjects,
                    trackers: newTrackers,
                    activities: newActivities
                };

                setWorkSettings(localWork);
                setRedmineApiConfig(localApiConfig);

                // Apply the fetched username if provided, otherwise use local state
                const finalUserName = overrideUserName !== null ? overrideUserName : localUserName;
                setLocalUserName(finalUserName); // Ensure local state is also updated
                setUserName(finalUserName); // Update parent state

                setStaticData(newStaticData);

                return {
                    userName: finalUserName,
                    workSettings: localWork,
                    redmineApiConfig: localApiConfig,
                    staticData: newStaticData
                };
            };

            const handleSaveAndClose = async () => {
                if (firebaseConfigStr) {
                    try {
                        JSON.parse(firebaseConfigStr);
                        const oldConfig = localStorage.getItem(LS_CONFIG_KEY);
                        if (oldConfig !== firebaseConfigStr) {
                            localStorage.setItem(LS_CONFIG_KEY, firebaseConfigStr);
                            alert("Firebase 設定已更新，頁面將重新整理以套用新設定。");
                            window.location.reload();
                            return;
                        }
                    } catch (e) {
                        try {
                            let jsStr = firebaseConfigStr.trim();
                            if (jsStr.indexOf('=') > -1) {
                                jsStr = jsStr.substring(jsStr.indexOf('=') + 1).trim();
                            }
                            if (jsStr.endsWith(';')) {
                                jsStr = jsStr.slice(0, -1);
                            }

                            const obj = new Function("return " + jsStr)();
                            if (obj && obj.apiKey) {
                                const finalConfigStr = JSON.stringify(obj);
                                const oldConfig = localStorage.getItem(LS_CONFIG_KEY);
                                if (oldConfig !== finalConfigStr) {
                                    localStorage.setItem(LS_CONFIG_KEY, finalConfigStr);
                                    alert("Firebase 設定已更新，頁面將重新整理以套用新設定。");
                                    window.location.reload();
                                    return;
                                }
                            } else {
                                throw new Error("Invalid Config");
                            }
                        } catch (e2) {
                            showAlert("設定錯誤", "Firebase 設定格式錯誤 (請輸入有效的 JSON 或直接貼上 Firebase Console 的程式碼)");
                            return;
                        }
                    }
                }

                let fetchedName = null;

                // 透過後端代理驗證連線 (需先建立 session)
                if (localApiConfig.apiKey && localApiConfig.host) {
                    const apiBase = localApiConfig.apiBaseUrl ? localApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                    try {
                        // 先建立 session
                        const loginRes = await fetch(`${apiBase}/api/auth/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                host: localApiConfig.host,
                                apiKey: localApiConfig.apiKey,
                                geminiApiKey: localApiConfig.geminiApiKey || '',
                                firebaseConfig: null,
                                corsProxy: localApiConfig.corsProxy || ''
                            }),
                            credentials: 'include'
                        });

                        if (loginRes.ok) {
                            fetchedName = await handleFetchUser(true);
                        }
                    } catch (e) {
                        console.error("Auto fetch user failed on save:", e);
                    }
                }

                if (getAndApplySettings(fetchedName)) {
                    onClose();
                }
            };

            const handleForceBackup = () => {
                const currentData = getAndApplySettings();
                if (currentData) {
                    onManualSave(currentData);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 modal-overlay p-4">
                    <div className="bg-white rounded-xl shadow-2xl max-w-lg w-full p-6 modal-content border border-gray-100 flex flex-col max-h-[90vh]">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="text-lg font-bold text-gray-800 flex items-center gap-2"><Icon name="settings" size={20} /> 設定</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600"><Icon name="x" /></button>
                        </div>

                        <div className="overflow-y-auto flex-grow pr-2 space-y-6">

                            {/* Cloud Sync Status */}
                            <div className="pb-4 border-b border-gray-100">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 flex items-center gap-2"><Icon name="cloud" size={16} /> 雲端同步狀態</h4>
                                <div className={`flex flex-col gap-3 p-3 rounded-lg border ${syncStatus === 'permission_error' ? 'bg-red-50 border-red-200' : 'bg-blue-50 border-blue-100'}`}>
                                    <div className="flex items-center justify-between">
                                        <div className="text-sm text-gray-600">
                                            狀態: <span className={`font-bold ${syncStatus === 'saved' ? 'text-green-600' :
                                                syncStatus === 'offline' ? 'text-yellow-600' :
                                                    syncStatus === 'error' || syncStatus === 'permission_error' ? 'text-red-600' : 'text-blue-600'}`}>
                                                {syncStatus === 'saved' ? '已同步' :
                                                    syncStatus === 'saving' ? '同步中...' :
                                                        syncStatus === 'offline' ? '暫時離線' :
                                                            syncStatus === 'permission_error' ? '權限不足 (無法寫入)' :
                                                                syncStatus === 'error' ? '同步失敗' : '等待中'}
                                            </span>
                                            {syncStatus === 'permission_error' && (
                                                <button onClick={onShowRulesHelp} className="ml-2 text-xs bg-red-600 text-white px-2 py-0.5 rounded hover:bg-red-700 underline">如何修復？</button>
                                            )}
                                        </div>
                                        <div className="text-xs text-gray-400">
                                            {lastSyncTime ? new Date(lastSyncTime).toLocaleTimeString() : '尚未同步'}
                                        </div>
                                    </div>

                                    <div className="mt-2">
                                        <label className="text-xs text-gray-500 block mb-1">Firebase 設定 (JSON)</label>
                                        <textarea
                                            value={firebaseConfigStr}
                                            onChange={e => setFirebaseConfigStr(e.target.value)}
                                            placeholder='請貼上 Firebase Config JSON: { "apiKey": "...", ... }'
                                            className="w-full border rounded px-2 py-1.5 text-xs font-mono h-20 resize-y focus:border-blue-500 outline-none"
                                        />
                                        <p className="text-[10px] text-gray-400 mt-1">
                                            若未填寫，將無法使用雲端同步功能。設定後請點擊儲存，系統將自動重整。
                                        </p>
                                    </div>

                                    <div className="flex gap-2 justify-end mt-1">
                                        <button
                                            onClick={handleForceBackup}
                                            className="bg-blue-600 text-white hover:bg-blue-700 px-3 py-1.5 rounded text-xs transition-colors flex items-center gap-1 shadow-sm"
                                            title="儲存目前設定並立即上傳雲端"
                                        >
                                            <Icon name="upload-cloud" size={14} /> 強制立即備份
                                        </button>
                                        <button
                                            onClick={onManualLoad}
                                            className="bg-white border border-blue-200 text-blue-600 hover:bg-blue-600 hover:text-white px-3 py-1.5 rounded text-xs transition-colors flex items-center gap-1 shadow-sm"
                                        >
                                            <Icon name="download-cloud" size={14} /> 從雲端還原
                                        </button>
                                    </div>
                                </div>
                            </div>

                            {/* Redmine API Settings */}
                            <div className="pb-4 border-b border-gray-100">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 flex items-center gap-2"><Icon name="server" size={16} /> Redmine API 連線</h4>
                                <div className="space-y-3">
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">網址 (Host URL)</label>
                                        <input
                                            type="text"
                                            placeholder="例如: https://igs.redmine-x.com"
                                            value={localApiConfig.host || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, host: e.target.value })}
                                            className="w-full border rounded px-2 py-1.5 text-sm"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">API 金鑰 (API Key)</label>
                                        <input
                                            type="password"
                                            placeholder="請至 Redmine 個人帳戶頁面取得"
                                            value={localApiConfig.apiKey || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, apiKey: e.target.value })}
                                            onBlur={handleAutoLoad}
                                            className="w-full border rounded px-2 py-1.5 text-sm"
                                        />
                                        <p className="text-[10px] text-gray-400 mt-1">
                                            提示：輸入金鑰後離開欄位，將自動載入用戶資訊與清單資料。
                                        </p>
                                    </div>

                                    {/* AI Settings */}
                                    <div className="pt-2 border-t border-gray-100 mt-2">
                                        <label className="text-xs text-gray-500 block mb-1 font-bold">AI 智慧分類 (Google Gemini)</label>
                                        <input
                                            type="password"
                                            placeholder="貼上 Gemini API Key 以啟用魔術棒"
                                            value={localApiConfig.geminiApiKey || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, geminiApiKey: e.target.value })}
                                            className="w-full border rounded px-2 py-1.5 text-sm font-mono border-purple-200 focus:border-purple-500"
                                        />
                                        <p className="text-[10px] text-gray-400 mt-1">
                                            若未填寫，魔術棒將使用基本關鍵字比對。
                                            <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-purple-500 hover:underline ml-1">取得 API Key</a>
                                        </p>
                                    </div>

                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">後端 API 網址 (正式環境必填)</label>
                                        <input
                                            type="text"
                                            placeholder="例如: https://api.example.com (開發時可留空)"
                                            value={localApiConfig.apiBaseUrl || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, apiBaseUrl: e.target.value })}
                                            className="w-full border rounded px-2 py-1.5 text-sm font-mono text-gray-600"
                                        />
                                        <p className="text-[10px] text-gray-400 mt-1">
                                            提示：正式上線時，請填入後端伺服器網址。開發時留空表示同源。
                                        </p>
                                    </div>

                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">CORS 代理 (選填，已棄用)</label>
                                        <input
                                            type="text"
                                            placeholder="已不再需要，可留空"
                                            value={localApiConfig.corsProxy || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, corsProxy: e.target.value })}
                                            className="w-full border rounded px-2 py-1.5 text-sm font-mono text-gray-400"
                                        />
                                        <p className="text-[10px] text-gray-400 mt-1">
                                            注意：現已改用後端代理，此欄位可留空。
                                        </p>
                                    </div>
                                </div>
                            </div>

                            {/* Work Hours Settings */}
                            <div className="pb-4 border-b border-gray-100">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 flex items-center gap-2"><Icon name="clock" size={16} /> 出勤時間設定</h4>
                                <div className="grid grid-cols-2 gap-4 mb-3">
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">上班時間</label>
                                        <input type="time" value={localWork.startTime} onChange={e => setLocalWork({ ...localWork, startTime: e.target.value })} className="w-full border rounded px-2 py-1.5 text-sm" />
                                    </div>
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">預設下班時間</label>
                                        <input type="time" value={localWork.endTime} onChange={e => setLocalWork({ ...localWork, endTime: e.target.value })} className="w-full border rounded px-2 py-1.5 text-sm" />
                                    </div>
                                </div>
                                <div>
                                    <label className="text-xs text-gray-500 block mb-1">午休/休息扣除 (小時)</label>
                                    <input type="number" step="0.5" value={localWork.breakHours} onChange={e => setLocalWork({ ...localWork, breakHours: parseFloat(e.target.value) })} className="w-full border rounded px-2 py-1.5 text-sm" />
                                </div>
                                <div className="flex items-center gap-2 mt-2">
                                    <input
                                        type="checkbox"
                                        id="deductDinner"
                                        checked={localWork.enableDinnerBreak !== false}
                                        onChange={e => setLocalWork({ ...localWork, enableDinnerBreak: e.target.checked })}
                                        className="rounded text-blue-600 focus:ring-blue-500"
                                    />
                                    <label htmlFor="deductDinner" className="text-sm text-gray-700 cursor-pointer select-none">
                                        自動扣除晚餐時間 (18:00 ~ 18:30)
                                    </label>
                                </div>
                            </div>

                            {/* Personal Settings (Fetch from Redmine) */}
                            <div className="pb-4 border-b border-gray-100">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 flex items-center gap-2"><Icon name="user" size={16} /> 個人設定</h4>
                                <div>
                                    <label className="text-xs text-gray-500 block mb-1">用戶名稱 (User Name)</label>
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            placeholder="您的姓名 (用於匯出報表)"
                                            value={localUserName || ''}
                                            onChange={e => setLocalUserName(e.target.value)}
                                            className="flex-grow border rounded px-2 py-1.5 text-sm"
                                        />
                                        <button
                                            onClick={() => handleFetchUser(false)}
                                            disabled={isFetching.user}
                                            className="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1.5 rounded text-xs flex items-center gap-1 transition-colors whitespace-nowrap"
                                        >
                                            {isFetching.user ? <Icon name="loader-2" className="animate-spin" size={14} /> : <Icon name="refresh-cw" size={14} />}
                                            從 Redmine 載入
                                        </button>
                                    </div>
                                </div>
                            </div>

                            {/* JSON Data Import */}
                            <div>
                                <h4 className="text-sm font-bold text-gray-700 mb-2 flex items-center gap-2"><Icon name="database" size={16} /> 下拉選單資料來源 (API URL)</h4>
                                <p className="text-xs text-gray-500 mb-3">請輸入完整 API URL (可包含 <code>{'{密鑰}'}</code> 佔位符)。支援多行 URL (分頁)。或輸入相對路徑如 <code>/projects.json</code>。<br />點擊「測試並儲存」會立即抓取資料並儲存至本地。</p>

                                <div className="space-y-4">
                                    <div>
                                        <div className="flex justify-between items-center mb-1">
                                            <label className="text-xs text-gray-500 font-bold">專案列表 API</label>
                                            <span className="text-[10px] text-gray-400">{staticData.projects?.length || 0} 筆</span>
                                        </div>
                                        <textarea
                                            value={localApiConfig.projectsApiUrl || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, projectsApiUrl: e.target.value })}
                                            placeholder={'例如:\n/projects.json?limit=100&offset=0&key={密鑰}\n/projects.json?limit=100&offset=100&key={密鑰}'}
                                            className="w-full border rounded px-2 py-1.5 text-xs font-mono h-20 resize-y focus:border-orange-500 outline-none"
                                        />
                                        <button onClick={() => handleFetchProjects(false)} disabled={isFetching.projects} className="mt-1 w-full bg-gray-100 hover:bg-gray-200 text-gray-700 text-xs py-1 rounded flex items-center justify-center gap-1">
                                            {isFetching.projects ? <Icon name="loader-2" className="animate-spin" size={12} /> : <Icon name="refresh-cw" size={12} />} 測試並儲存專案清單
                                        </button>
                                    </div>

                                    <div>
                                        <div className="flex justify-between items-center mb-1">
                                            <label className="text-xs text-gray-500 font-bold">追蹤標籤 API</label>
                                            <span className="text-[10px] text-gray-400">{staticData.trackers?.length || 0} 筆</span>
                                        </div>
                                        <textarea
                                            value={localApiConfig.trackersApiUrl || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, trackersApiUrl: e.target.value })}
                                            placeholder='例如: /projects/old_web.json?include=trackers&key={密鑰}'
                                            className="w-full border rounded px-2 py-1.5 text-xs font-mono h-12 resize-y focus:border-orange-500 outline-none"
                                        />
                                        <button onClick={() => handleFetchTrackers(false)} disabled={isFetching.trackers} className="mt-1 w-full bg-gray-100 hover:bg-gray-200 text-gray-700 text-xs py-1 rounded flex items-center justify-center gap-1">
                                            {isFetching.trackers ? <Icon name="loader-2" className="animate-spin" size={12} /> : <Icon name="refresh-cw" size={12} />} 測試並儲存標籤清單
                                        </button>
                                    </div>

                                    <div>
                                        <div className="flex justify-between items-center mb-1">
                                            <label className="text-xs text-gray-500 font-bold">工時-活動類型 API</label>
                                            <span className="text-[10px] text-gray-400">{staticData.activities?.length || 0} 筆</span>
                                        </div>
                                        <textarea
                                            value={localApiConfig.activitiesApiUrl || ''}
                                            onChange={e => setLocalApiConfig({ ...localApiConfig, activitiesApiUrl: e.target.value })}
                                            placeholder='例如: /enumerations/time_entry_activities.json?key={密鑰}'
                                            className="w-full border rounded px-2 py-1.5 text-xs font-mono h-12 resize-y focus:border-orange-500 outline-none"
                                        />
                                        <button onClick={() => handleFetchActivities(false)} disabled={isFetching.activities} className="mt-1 w-full bg-gray-100 hover:bg-gray-200 text-gray-700 text-xs py-1 rounded flex items-center justify-center gap-1">
                                            {isFetching.activities ? <Icon name="loader-2" className="animate-spin" size={12} /> : <Icon name="refresh-cw" size={12} />} 測試並儲存活動清單
                                        </button>
                                    </div>

                                    {/* Fallback Manual JSON Paste (Hidden by default or below) */}
                                    <div className="pt-4 border-t border-gray-100 mt-4">
                                        <details>
                                            <summary className="text-xs text-gray-400 cursor-pointer hover:text-gray-600">手動貼上 JSON (備用)</summary>
                                            <div className="space-y-3 mt-2">
                                                <div><label className="text-xs text-gray-500 block mb-1">專案清單 JSON</label><textarea value={projectsJson} onChange={e => setProjectsJson(e.target.value)} placeholder='貼上 JSON...' className="w-full border rounded px-2 py-1.5 text-xs font-mono h-16 resize-y focus:border-orange-500 outline-none" /></div>
                                                <div><label className="text-xs text-gray-500 block mb-1">追蹤標籤 JSON</label><textarea value={trackersJson} onChange={e => setTrackersJson(e.target.value)} placeholder='貼上 JSON...' className="w-full border rounded px-2 py-1.5 text-xs font-mono h-16 resize-y focus:border-orange-500 outline-none" /></div>
                                                <div><label className="text-xs text-gray-500 block mb-1">工時活動 JSON</label><textarea value={activitiesJson} onChange={e => setActivitiesJson(e.target.value)} placeholder='貼上 JSON...' className="w-full border rounded px-2 py-1.5 text-xs font-mono h-16 resize-y focus:border-orange-500 outline-none" /></div>
                                            </div>
                                        </details>
                                    </div>

                                </div>
                            </div>
                        </div>
                        <div className="flex justify-end pt-4 border-t mt-2">
                            <button onClick={handleSaveAndClose} className="bg-red-600 text-white px-6 py-2 rounded hover:bg-red-700 text-sm font-bold shadow-md">儲存設定並關閉</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Searchable Select Component ---
        const SearchableSelect = ({ label, value, onChange, options = [], placeholder, emptyText = "無資料" }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [search, setSearch] = useState('');
            const wrapperRef = useRef(null);
            const inputRef = useRef(null);
            const listRef = useRef(null);

            useEffect(() => {
                const selectedOption = options.find(o => String(o.id) === String(value));
                if (selectedOption) setSearch(selectedOption.name);
                else if (value && value !== search) setSearch(value);
                else if (!value) setSearch('');
            }, [value, options]);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) setIsOpen(false);
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            // Scroll to selected item when opened
            useEffect(() => {
                if (isOpen && listRef.current) {
                    const selectedEl = listRef.current.querySelector('[data-selected="true"]');
                    if (selectedEl) {
                        selectedEl.scrollIntoView({ block: 'nearest' });
                    }
                }
            }, [isOpen]);

            const filteredOptions = (() => {
                const selectedOption = options.find(o => String(o.id) === String(value));
                if (selectedOption && search === selectedOption.name) {
                    return options;
                }
                return options.filter(o => o.name.toLowerCase().includes(search.toLowerCase()));
            })();

            const handleSelect = (option) => {
                onChange(option.id);
                setSearch(option.name);
                setIsOpen(false);
            };

            const handleInputChange = (e) => {
                const newValue = e.target.value;
                setSearch(newValue);
                onChange(newValue);
                setIsOpen(true);
            };

            const toggleOpen = () => {
                setIsOpen(!isOpen);
                if (!isOpen && inputRef.current) {
                    inputRef.current.focus();
                }
            };

            return (
                <div className="relative" ref={wrapperRef}>
                    <label className="text-xs text-gray-500 mb-0.5 block">{label}</label>
                    <div className="relative w-full">
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder={placeholder}
                            value={search}
                            onChange={handleInputChange}
                            onFocus={() => setIsOpen(true)}
                            className="w-full border rounded px-2 py-1.5 focus:border-orange-500 outline-none text-sm bg-white pr-8"
                        />
                        <div
                            className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 cursor-pointer hover:text-gray-600"
                            onClick={toggleOpen}
                        >
                            <Icon name="chevron-down" size={14} />
                        </div>
                        {isOpen && filteredOptions.length > 0 && (
                            <ul ref={listRef} className="absolute z-50 w-full bg-white border border-gray-200 rounded shadow-lg max-h-48 overflow-y-auto mt-1 text-sm">
                                {filteredOptions.map(option => (
                                    <li
                                        key={option.id}
                                        data-selected={String(option.id) === String(value)}
                                        onClick={() => handleSelect(option)}
                                        className={`px-3 py-2 cursor-pointer hover:bg-orange-50 ${String(option.id) === String(value) ? 'bg-orange-100 text-orange-900 font-medium' : 'text-gray-700'}`}
                                    >
                                        {option.name}
                                    </li>
                                ))}
                            </ul>
                        )}
                        {isOpen && filteredOptions.length === 0 && (
                            <ul className="absolute z-50 w-full bg-white border border-gray-200 rounded shadow-lg mt-1 text-sm">
                                <li className="px-3 py-2 text-gray-400 text-center">{options.length === 0 ? emptyText : "無符合選項 (可直接輸入)"}</li>
                            </ul>
                        )}
                    </div>
                </div>
            );
        };

        // --- Time Input Component ---
        const TimeInput = ({ duration, isRunning, onUpdate }) => {
            const pad = (n) => n.toString().padStart(2, '0');
            const h = Math.floor(duration / 3600000);
            const m = Math.floor((duration % 3600000) / 60000);
            const s = Math.floor((duration % 60000) / 1000);

            const handleChange = (part, value) => {
                const cleanVal = value.replace(/\D/g, '');
                let val = parseInt(cleanVal);
                if (isNaN(val)) val = 0;

                let newDuration = duration;
                if (part === 'h') newDuration = (val * 3600000) + (m * 60000) + (s * 1000);
                if (part === 'm') newDuration = (h * 3600000) + (val * 60000) + (s * 1000);
                if (part === 's') newDuration = (h * 3600000) + (m * 60000) + (val * 1000);

                onUpdate(newDuration);
            };

            const baseInputClass = `bg-transparent border-b border-transparent hover:border-gray-300 focus:border-red-500 focus:outline-none text-center p-0 transition-colors cursor-text ${isRunning ? 'text-green-600' : 'text-gray-600'}`;

            return (
                <div className="font-mono text-2xl font-bold tracking-wider flex items-center justify-end">
                    <input
                        type="text"
                        inputMode="numeric"
                        className={`${baseInputClass} w-[3ch] text-right`}
                        value={pad(h)}
                        onChange={(e) => handleChange('h', e.target.value)}
                        onFocus={(e) => e.target.select()}
                        aria-label="Hours"
                    />
                    <span className={`mx-0.5 ${isRunning ? 'text-green-600' : 'text-gray-400'}`}>:</span>
                    <input
                        type="text"
                        inputMode="numeric"
                        className={`${baseInputClass} w-[2ch]`}
                        value={pad(m)}
                        onChange={(e) => handleChange('m', e.target.value)}
                        onFocus={(e) => e.target.select()}
                        aria-label="Minutes"
                    />
                    <span className={`mx-0.5 ${isRunning ? 'text-green-600' : 'text-gray-400'}`}>:</span>
                    <input
                        type="text"
                        inputMode="numeric"
                        className={`${baseInputClass} w-[2ch] text-gray-400 text-xl`}
                        style={{ opacity: isRunning ? 1 : 0.6 }}
                        value={pad(s)}
                        onChange={(e) => handleChange('s', e.target.value)}
                        onFocus={(e) => e.target.select()}
                        aria-label="Seconds"
                    />
                </div>
            );
        };

        // --- Task Textarea Component ---
        const TaskTextarea = ({ value, onChange }) => {
            const textareaRef = useRef(null);

            useEffect(() => {
                const adjustHeight = () => {
                    if (textareaRef.current) {
                        textareaRef.current.style.height = 'auto'; // Reset height
                        textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px'; // Set to content height
                    }
                };

                adjustHeight();

                // Fallback for batch updates or fast state changes
                const timer = setTimeout(adjustHeight, 0);
                return () => clearTimeout(timer);
            }, [value]);

            return (
                <textarea
                    ref={textareaRef}
                    value={value}
                    onChange={onChange}
                    rows={1}
                    placeholder="請輸入任務說明..."
                    className="w-full bg-transparent border border-transparent hover:border-gray-200 focus:border-red-500 rounded px-2 py-1 resize-none focus:outline-none focus:bg-white transition-colors text-gray-800 font-medium leading-normal block -ml-2"
                />
            );
        };

        // --- Redmine Gap Filler Section ---
        const RedmineGapFiller = ({ gapHours, date, showAlert, staticData, onSuccess, redmineApiConfig, setRedmineApiConfig, state, setState, prepareFetchUrl }) => {
            const { subject, description, doneRatio, enabled } = state;
            const [loading, setLoading] = useState(false);
            const [createLog, setCreateLog] = useState(true);

            const updateField = (field, value) => {
                setState(prev => ({ ...prev, [field]: value }));
            };

            const updateConfig = (key, val) => setRedmineApiConfig(prev => ({ ...prev, [key]: val }));

            // Helper to get fetch URL (apply proxy if needed) - Removed legacy helper

            const handleCreate = async () => {
                if (!redmineApiConfig.host || !redmineApiConfig.apiKey) return showAlert("錯誤", "請先至右上角「設定」填寫 Redmine URL 與 API Key");
                if (!redmineApiConfig.projectId) return showAlert("錯誤", "請選擇專案");

                setLoading(true);

                try {
                    const issuePayload = { issue: { project_id: redmineApiConfig.projectId, tracker_id: redmineApiConfig.trackerId, subject: subject, description: description, done_ratio: doneRatio } };

                    const issueRes = await fetch(prepareFetchUrl("/issues.json"), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(issuePayload),
                        credentials: 'include'
                    });

                    if (!issueRes.ok) throw new Error(`建立 Issue 失敗: ${issueRes.status} ${issueRes.statusText}`);
                    const issueData = await issueRes.json();
                    const newIssueId = issueData.issue.id;
                    let successMsg = `成功建立 Issue #${newIssueId}！`;

                    if (createLog) {
                        if (!redmineApiConfig.timeActivityId) throw new Error("回報工時需填寫工時活動 ID");

                        const timeRes = await fetch(prepareFetchUrl("/time_entries.json"), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ time_entry: { issue_id: newIssueId, hours: gapHours, activity_id: redmineApiConfig.timeActivityId, spent_on: date, comments: '系統自動補單' } }),
                            credentials: 'include'
                        });

                        if (!timeRes.ok) throw new Error(`工時回報失敗: ${timeRes.status}`);
                        successMsg += `\n並已寫入 ${gapHours} 小時工時。`;
                    }
                    showAlert("成功", successMsg);
                    if (onSuccess) onSuccess(newIssueId, gapHours);
                } catch (e) {
                    console.error("API Error:", e);
                    let title = "API 連線失敗"; let msg = e.message;
                    if (e.name === 'TypeError' && e.message === 'Failed to fetch') {
                        title = "連線失敗";
                        msg = "無法連接到後端伺服器或 Redmine。\n請檢查後端服務是否正在執行。";
                    }
                    showAlert(title, msg);
                } finally { setLoading(false); }
            };

            const hasStaticData = staticData.projects.length > 0 || staticData.trackers.length > 0;

            return (
                <div className="bg-orange-50 border border-orange-200 rounded-xl p-4 mb-6 shadow-sm text-sm">
                    <div className="flex items-center justify-between mb-4">
                        <div className="flex items-center gap-2 text-orange-800 font-bold text-base">
                            <Icon name="alert-circle" size={20} />
                            <span>工時不足 {gapHours} 小時</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <input
                                type="checkbox"
                                id="enableGapFiller"
                                checked={enabled}
                                onChange={(e) => updateField('enabled', e.target.checked)}
                                className="rounded text-orange-600 focus:ring-orange-500 w-4 h-4"
                            />
                            <label htmlFor="enableGapFiller" className="font-bold text-gray-700 cursor-pointer select-none">啟用自動補單</label>
                        </div>
                    </div>

                    {enabled && (
                        <div className="animate-fade-in">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                <div className="space-y-3 p-3 bg-orange-100/50 rounded-lg border border-orange-100">
                                    <div className="flex justify-between items-center"><label className="block font-bold text-orange-900 flex items-center gap-1"><Icon name="settings-2" size={14} /> Redmine 設定</label>{hasStaticData && <span className="text-xs text-green-600 bg-green-100 px-2 py-0.5 rounded">已載入設定資料</span>}</div>
                                    {(!redmineApiConfig.host || !redmineApiConfig.apiKey) && <div className="text-xs text-red-600 bg-red-50 p-2 rounded border border-red-200"><Icon name="alert-triangle" size={12} className="inline mr-1" />請點擊右上角「設定」按鈕，填寫 Redmine 網址與 API Key。</div>}
                                    <SearchableSelect label="專案 (Project)" placeholder="輸入 ID 或搜尋..." value={redmineApiConfig.projectId} onChange={(val) => updateConfig('projectId', val)} options={staticData.projects} emptyText="無資料，請至設定匯入 API" />
                                    <div className="grid grid-cols-2 gap-2">
                                        <SearchableSelect label="追蹤標籤 (Tracker)" placeholder="輸入 ID 或搜尋..." value={redmineApiConfig.trackerId} onChange={(val) => updateConfig('trackerId', val)} options={staticData.trackers} emptyText="無資料，請至設定匯入 API" />
                                        <SearchableSelect label="工時-活動類型 (Activity)" placeholder="輸入 ID 或搜尋..." value={redmineApiConfig.timeActivityId} onChange={(val) => updateConfig('timeActivityId', val)} options={staticData.activities} emptyText="無資料，請至設定匯入 API" />
                                    </div>
                                </div>
                                <div className="space-y-3 p-3 bg-white rounded-lg border border-gray-200">
                                    <label className="block font-bold text-gray-700 flex items-center gap-1"><Icon name="file-plus" size={14} /> 補單內容</label>
                                    <div><label className="text-xs text-gray-500 mb-0.5 block">主旨</label><input type="text" placeholder="主旨" value={subject} onChange={e => updateField('subject', e.target.value)} className="w-full border rounded px-2 py-1.5 focus:border-orange-500 outline-none" /></div>
                                    <div><label className="text-xs text-gray-500 mb-0.5 block">概述</label><textarea placeholder="概述" rows={4} value={description} onChange={e => updateField('description', e.target.value)} className="w-full border rounded px-2 py-1.5 resize-none focus:border-orange-500 outline-none" /></div>
                                    <div><label className="text-xs text-gray-500 mb-0.5 block">完成百分比</label><select value={doneRatio} onChange={e => updateField('doneRatio', e.target.value)} className="w-full border rounded px-2 py-1.5 focus:border-orange-500 outline-none bg-white">{[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map(r => <option key={r} value={r}>{r}%</option>)}</select></div>
                                </div>
                            </div>
                            <div className="flex items-center justify-between pt-3 border-t border-orange-200">
                                <label className="flex items-center gap-2 text-gray-700 cursor-pointer select-none font-medium"><input type="checkbox" checked={createLog} onChange={e => setCreateLog(e.target.checked)} className="rounded text-orange-600 focus:ring-orange-500" /><span>同時回報工時 (Log Time)</span></label>
                                <button onClick={handleCreate} disabled={loading} className="bg-orange-600 hover:bg-orange-700 text-white px-6 py-2.5 rounded-lg font-bold flex items-center gap-2 disabled:opacity-50 transition-colors shadow-sm">{loading ? <Icon name="loader-2" className="animate-spin" size={18} /> : <Icon name="send" size={18} />}{loading ? "處理中..." : "建立單據"}</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Daily Activity Panel ---
        const DailyActivityPanel = ({ date, redmineApiConfig, redmineUserId, onAddTask, showAlert, staticData, localUserName, onBatchAdd, prepareFetchUrl }) => {
            const [activities, setActivities] = useState([]);
            const [loading, setLoading] = useState(false);
            const [expandedIds, setExpandedIds] = useState(new Set());
            const [isAllExpanded, setIsAllExpanded] = useState(false);
            const [showRulesHelp, setShowRulesHelp] = useState(false); // Rules Help Modal
            const [progress, setProgress] = useState(null); // { current, total, text }
            const [selectedProjectIds, setSelectedProjectIds] = useState(new Set());
            const [isProjectFilterOpen, setIsProjectFilterOpen] = useState(false);
            const [projectFilterSearch, setProjectFilterSearch] = useState(""); // New state for search
            const [selectedActivityIds, setSelectedActivityIds] = useState(new Set()); // For batch selection

            const fetchWithRetry = async (url, options, retries = 3, backoff = 300) => {
                for (let i = 0; i < retries; i++) {
                    try {
                        const res = await fetch(url, options);
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        return res;
                    } catch (err) {
                        if (i === retries - 1) throw err;
                        await new Promise(r => setTimeout(r, backoff * (i + 1)));
                    }
                }
            };

            const delay = (ms) => new Promise(r => setTimeout(r, ms));

            const fetchActivities = async () => {
                if (!redmineApiConfig.host || !redmineApiConfig.apiKey) {
                    showAlert("提示", "請先至「設定」設定 Redmine 連線資訊。");
                    return;
                }

                setLoading(true);
                setProgress(null);
                setActivities([]);
                setSelectedActivityIds(new Set()); // Reset selection on new search

                try {
                    let candidates = [];

                    let targetProjects = [];
                    if (selectedProjectIds.size > 0) {
                        if (!staticData || !staticData.projects) {
                            showAlert("錯誤", "專案列表未載入");
                            setLoading(false);
                            return;
                        }
                        targetProjects = staticData.projects.filter(p => selectedProjectIds.has(p.id));
                        console.log(`[RedmineDebug] Selected Projects mode. Count: ${targetProjects.length}`);
                    }

                    if (targetProjects.length > 0) {
                        setProgress({ current: 0, total: targetProjects.length, text: "正在掃描選定專案..." });
                        let allIssues = [];
                        const projectChunks = [];
                        const pChunkSize = 5;
                        for (let i = 0; i < targetProjects.length; i += pChunkSize) {
                            projectChunks.push(targetProjects.slice(i, i + pChunkSize));
                        }

                        let processed = 0;
                        for (const chunk of projectChunks) {
                            const promises = chunk.map(p => {
                                // 使用相對路徑，讓 prepareFetchUrl 處理
                                const url = `/issues.json?project_id=${p.id}&updated_on=${date}&status_id=*&limit=100&nometa=1`;
                                console.log(`[RedmineDebug] Scanning Project: ${p.name} (ID: ${p.id}) URL: ${url}`);
                                return fetchWithRetry(prepareFetchUrl(url), { credentials: 'include' })
                                    .then(r => safeFetchJson(r)).catch(() => ({ issues: [] }));
                            });

                            const results = await Promise.all(promises);
                            results.forEach(r => { if (r.issues) allIssues.push(...r.issues); });

                            processed += chunk.length;
                            setProgress(prev => ({ ...prev, current: processed }));
                            await delay(100);
                        }
                        candidates = allIssues;

                    } else {
                        try {
                            const limit = 100;
                            const commonParams = `&limit=${limit}&nometa=1`;

                            const queries = [
                                { url: `/issues.json?updated_on=${date}&status_id=*${commonParams}`, name: 'Global' },
                                { url: `/issues.json?updated_on=${date}&assigned_to_id=me&status_id=*${commonParams}`, name: 'Assigned' },
                                { url: `/issues.json?updated_on=${date}&author_id=me&status_id=*${commonParams}`, name: 'Author' },
                                { url: `/issues.json?updated_on=${date}&watcher_id=me&status_id=*${commonParams}`, name: 'Watcher' },
                                { url: `/issues.json?updated_on=${date}&updated_by=me&status_id=*${commonParams}`, name: 'UpdatedBy' }
                            ];

                            console.log(`[RedmineDebug] Attempting Global Search with URLs paths:`, queries.map(q => q.url));

                            const queryResults = await Promise.allSettled(queries.map(q =>
                                fetch(prepareFetchUrl(q.url), { credentials: 'include' })
                                    .then(async res => {
                                        if (res.status === 403) throw new Error("403");
                                        if (!res.ok) throw new Error(`List fetch failed`);
                                        return safeFetchJson(res);
                                    })
                            ));

                            let globalForbidden = false;

                            queryResults.forEach((res, index) => {
                                if (res.status === 'fulfilled' && res.value.issues) {
                                    candidates.push(...res.value.issues);
                                } else if (res.status === 'rejected' && res.reason.message === "403") {
                                    if (index === 0) globalForbidden = true;
                                }
                            });

                            if (globalForbidden) {
                                console.warn("[RedmineDebug] Global fetch forbidden (403), executing per-project scan...");

                                if (!staticData || !staticData.projects || staticData.projects.length === 0) {
                                    showAlert("權限受限", "全域搜尋被拒 (403)，且無專案列表可供掃描。\n請先至「設定」點擊「測試並儲存專案清單」，以便進行逐專案搜尋。");
                                    setLoading(false);
                                    return;
                                }

                                let allIssues = [];
                                const projectChunks = [];
                                const pChunkSize = 5;
                                for (let i = 0; i < staticData.projects.length; i += pChunkSize) {
                                    projectChunks.push(staticData.projects.slice(i, i + pChunkSize));
                                }

                                let processedProjects = 0;
                                setProgress({ current: 0, total: staticData.projects.length, text: "正在掃描專案..." });

                                for (const chunk of projectChunks) {
                                    const promises = chunk.map(p => {
                                        const url = `/issues.json?project_id=${p.id}&updated_on=${date}&status_id=*&limit=100&nometa=1`;
                                        console.log(`[RedmineDebug] Scanning Project: ${p.name} URL: ${url}`);
                                        return fetchWithRetry(prepareFetchUrl(url), { credentials: 'include' })
                                            .then(r => safeFetchJson(r)).catch(() => ({ issues: [] }));
                                    });
                                    const results = await Promise.all(promises);
                                    results.forEach(r => { if (r.issues) allIssues.push(...r.issues); });

                                    processedProjects += chunk.length;
                                    setProgress(prev => ({ ...prev, current: processedProjects }));
                                    await delay(200);
                                }
                                candidates.push(...allIssues);
                            }
                        } catch (e) {
                            throw e;
                        }
                    }

                    // Deduplicate
                    const seen = new Set();
                    candidates = candidates.filter(item => {
                        if (seen.has(item.id)) return false;
                        seen.add(item.id);
                        return true;
                    });

                    console.log(`[RedmineDebug] Total Candidates Found: ${candidates.length}`, candidates);

                    const results = [];
                    const chunks = [];
                    const chunkSize = 5;
                    for (let i = 0; i < candidates.length; i += chunkSize) {
                        chunks.push(candidates.slice(i, i + chunkSize));
                    }

                    let processedIssues = 0;
                    setProgress({ current: 0, total: candidates.length, text: "正在讀取筆記..." });

                    for (const chunk of chunks) {
                        const promises = chunk.map(async (issue) => {
                            try {
                                console.log(`[RedmineDebug] Checking Issue #${issue.id}`);
                                const detailUrl = prepareFetchUrl(`/issues/${issue.id}.json?include=journals`);
                                const detailRes = await fetchWithRetry(detailUrl, { credentials: 'include' });
                                if (!detailRes.ok) return null;
                                const detailData = await safeFetchJson(detailRes);
                                const fullIssue = detailData.issue;

                                const userJournals = (fullIssue.journals || []).filter(j => {
                                    // Check user match
                                    const userMatch = j.user.id === redmineUserId;

                                    // Robust date comparison
                                    const journalDate = new Date(j.created_on);
                                    const localJournalDate = journalDate.getFullYear() + '-' +
                                        String(journalDate.getMonth() + 1).padStart(2, '0') + '-' +
                                        String(journalDate.getDate()).padStart(2, '0');

                                    const dateMatch = localJournalDate === date;
                                    const hasContent = (j.notes && j.notes.trim().length > 0) || (j.details && j.details.length > 0);

                                    if (!dateMatch) console.log(`[RedmineDebug] Journal Skipped: Date ${localJournalDate} !== ${date}`);

                                    return userMatch && dateMatch && hasContent;
                                });

                                if (userJournals.length > 0) {
                                    console.log(`[RedmineDebug] Match Found: Issue #${fullIssue.id}`);
                                    return {
                                        id: fullIssue.id,
                                        project: fullIssue.project.name,
                                        subject: fullIssue.subject,
                                        notes: userJournals.map(j => {
                                            const time = new Date(j.created_on).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                            let content = "";
                                            if (j.notes) content += stripHtml(j.notes);
                                            if (j.details && j.details.length > 0) {
                                                const detailsText = j.details.map(d => `[系統] ${d.name}: ${d.old_value || '(無)'} -> ${d.new_value}`).join('\n');
                                                content += (content ? '\n' : '') + detailsText;
                                            }
                                            return `[${time}] ${content}`;
                                        }).join('\n\n---\n\n')
                                    };
                                }
                                return null;
                            } catch (e) {
                                console.warn(`Error fetching issue ${issue.id}, skipping.`);
                                return null;
                            }
                        });

                        const chunkResults = await Promise.all(promises);
                        results.push(...chunkResults.filter(r => r !== null));

                        processedIssues += chunk.length;
                        setProgress(prev => ({ ...prev, current: processedIssues }));
                        await delay(200); // Throttling
                    }

                    console.log(`[RedmineDebug] Final Results: ${results.length}`, results);
                    setActivities(results);
                    if (results.length === 0) {
                        if (!redmineUserId) {
                            showAlert("提示", "搜尋完成，但未找到結果。\n\n注意：系統尚未取得您的 User ID，因此無法篩選出「您」的足跡。\n請至「設定 > 個人設定」點擊「從 Redmine 載入」。");
                        } else {
                            showAlert("提示", "該日期沒有找到您參與並留言/修改的議題。");
                        }
                    }

                } catch (e) {
                    console.error(e);
                    showAlert("查詢失敗", e.message);
                } finally {
                    setLoading(false);
                    setProgress(null);
                }
            };

            const toggleExpand = (id) => {
                const newSet = new Set(expandedIds);
                if (newSet.has(id)) newSet.delete(id);
                else newSet.add(id);
                setExpandedIds(newSet);
            };

            const toggleAll = () => {
                if (isAllExpanded) {
                    setExpandedIds(new Set());
                } else {
                    setExpandedIds(new Set(activities.map(a => a.id)));
                }
                setIsAllExpanded(!isAllExpanded);
            };

            const handleProjectToggle = (pid) => {
                const newSet = new Set(selectedProjectIds);
                if (newSet.has(pid)) newSet.delete(pid);
                else newSet.add(pid);
                setSelectedProjectIds(newSet);
            };

            // --- Batch Operations ---
            const toggleSelectActivity = (id) => {
                const newSet = new Set(selectedActivityIds);
                if (newSet.has(id)) newSet.delete(id);
                else newSet.add(id);
                setSelectedActivityIds(newSet);
            };

            const toggleSelectAllActivities = () => {
                if (selectedActivityIds.size === activities.length) {
                    setSelectedActivityIds(new Set());
                } else {
                    setSelectedActivityIds(new Set(activities.map(a => a.id)));
                }
            };

            const handleBatchAdd = () => {
                const itemsToAdd = activities.filter(a => selectedActivityIds.has(a.id)).map(a => ({
                    issueId: a.id,
                    comment: a.notes,
                    projectName: a.project
                }));
                onBatchAdd(itemsToAdd);
                setSelectedActivityIds(new Set());
            };

            const filteredProjects = staticData && staticData.projects ? staticData.projects.filter(p => p.name.toLowerCase().includes(projectFilterSearch.toLowerCase())) : [];

            return (
                <div className="bg-white p-4 rounded-xl shadow-sm mb-6 border border-gray-100">
                    <div className="flex justify-between items-start mb-3 gap-2">
                        <div className="flex flex-col gap-2 flex-grow">
                            <div className="flex items-center gap-2">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                    <Icon name="history" size={18} /> Redmine 當日足跡
                                </h3>
                                <button
                                    onClick={fetchActivities}
                                    disabled={loading}
                                    className={`text-xs px-2 py-1 rounded transition-colors flex items-center gap-1 ${loading ? 'bg-gray-100 text-gray-400' : 'bg-indigo-50 text-indigo-600 hover:bg-indigo-100'}`}
                                >
                                    {loading ? <Icon name="loader-2" className="animate-spin" size={12} /> : <Icon name="search" size={12} />}
                                    {loading ? '搜尋中...' : '搜尋'}
                                </button>

                                <div className="relative">
                                    <button
                                        onClick={() => setIsProjectFilterOpen(!isProjectFilterOpen)}
                                        className={`text-xs px-2 py-1 rounded border flex items-center gap-1 transition-colors ${selectedProjectIds.size > 0 ? 'bg-orange-50 border-orange-200 text-orange-600' : 'bg-white border-gray-200 text-gray-500 hover:bg-gray-50'}`}
                                    >
                                        <Icon name="filter" size={12} />
                                        {selectedProjectIds.size > 0 ? `已選 ${selectedProjectIds.size} 專案` : '篩選專案'}
                                    </button>

                                    {isProjectFilterOpen && (
                                        <div className="absolute top-full left-0 mt-1 w-64 bg-white border border-gray-200 rounded-lg shadow-xl z-50 max-h-60 overflow-y-auto p-2 flex flex-col">
                                            <div className="mb-2">
                                                <input
                                                    type="text"
                                                    placeholder="搜尋專案..."
                                                    value={projectFilterSearch}
                                                    onChange={(e) => setProjectFilterSearch(e.target.value)}
                                                    className="w-full border rounded px-2 py-1 text-xs outline-none focus:border-indigo-500"
                                                    autoFocus
                                                />
                                            </div>
                                            <div className="flex-grow overflow-y-auto space-y-1">
                                                <div
                                                    onClick={() => setSelectedProjectIds(new Set())}
                                                    className={`px-2 py-1.5 rounded cursor-pointer text-xs ${selectedProjectIds.size === 0 ? 'bg-indigo-50 text-indigo-600 font-bold' : 'hover:bg-gray-50 text-gray-700'}`}
                                                >
                                                    全部 (自動判斷)
                                                </div>
                                                {filteredProjects.length > 0 ? filteredProjects.map(p => (
                                                    <label key={p.id} className="flex items-center gap-2 px-2 py-1 hover:bg-gray-50 rounded cursor-pointer">
                                                        <input
                                                            type="checkbox"
                                                            checked={selectedProjectIds.has(p.id)}
                                                            onChange={() => handleProjectToggle(p.id)}
                                                            className="rounded text-indigo-600 focus:ring-indigo-500 w-3 h-3"
                                                        />
                                                        <span className="text-xs text-gray-700 truncate" title={p.name}>{p.name}</span>
                                                    </label>
                                                )) : <div className="text-xs text-gray-400 p-2 text-center">無符合專案</div>}
                                            </div>
                                            <div className="pt-2 border-t mt-2 flex justify-end">
                                                <button onClick={() => setIsProjectFilterOpen(false)} className="text-xs bg-gray-800 text-white px-2 py-1 rounded">確定</button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                {selectedActivityIds.size > 0 && (
                                    <button
                                        onClick={handleBatchAdd}
                                        className="text-xs bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700 transition-colors flex items-center gap-1 shadow-sm font-bold ml-2"
                                    >
                                        <Icon name="plus-circle" size={14} />
                                        批次加入 ({selectedActivityIds.size})
                                    </button>
                                )}
                            </div>

                            {/* Selected Projects Tags */}
                            {selectedProjectIds.size > 0 && (
                                <div className="flex flex-wrap gap-2 items-center bg-gray-50 p-2 rounded-lg border border-gray-100 w-full mt-2">
                                    <span className="text-xs text-gray-400 font-bold">已鎖定:</span>
                                    {staticData.projects
                                        .filter(p => selectedProjectIds.has(p.id))
                                        .map(p => (
                                            <span key={p.id} className="inline-flex items-center gap-1 px-2 py-1 rounded bg-white border border-gray-200 text-xs text-gray-600 shadow-sm">
                                                {p.name}
                                                <button
                                                    onClick={() => handleProjectToggle(p.id)}
                                                    className="text-gray-400 hover:text-red-500 transition-colors"
                                                >
                                                    <Icon name="x" size={12} />
                                                </button>
                                            </span>
                                        ))
                                    }
                                    <button
                                        onClick={() => setSelectedProjectIds(new Set())}
                                        className="text-xs text-red-400 hover:text-red-600 underline ml-auto"
                                    >
                                        清除全部
                                    </button>
                                </div>
                            )}

                            {/* User Info Display */}
                            {redmineUserId && (
                                <div className="text-[10px] text-gray-400 flex items-center gap-1 ml-1">
                                    <Icon name="user-check" size={10} />
                                    <span>當前篩選用戶: {localUserName} (ID: {redmineUserId})</span>
                                </div>
                            )}
                        </div>
                        <div className="flex flex-col items-end gap-2">
                            {activities.length > 0 && (
                                <div className="flex items-center gap-2">
                                    <label className="flex items-center gap-1 text-xs text-gray-500 cursor-pointer select-none">
                                        <input
                                            type="checkbox"
                                            checked={activities.length > 0 && selectedActivityIds.size === activities.length}
                                            onChange={toggleSelectAllActivities}
                                            className="rounded text-indigo-600 focus:ring-indigo-500"
                                        />
                                        全選
                                    </label>
                                    <button onClick={toggleAll} className="text-xs text-gray-400 hover:text-gray-600">
                                        {isAllExpanded ? '全部收合' : '全部展開'}
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>

                    {progress && (
                        <div className="mb-3 text-xs text-blue-600 bg-blue-50 px-2 py-1 rounded flex items-center gap-2">
                            <Icon name="loader-2" className="animate-spin" size={12} />
                            <span>{progress.text} ({progress.current}/{progress.total})</span>
                        </div>
                    )}

                    {activities.length > 0 ? (
                        <div className="space-y-3">
                            {activities.map(act => (
                                <div key={act.id} className={`border rounded-lg p-3 transition-colors ${selectedActivityIds.has(act.id) ? 'border-green-300 bg-green-50/30' : 'border-gray-100 hover:border-gray-300'}`}>
                                    <div className="flex justify-between items-start gap-2">
                                        <div className="flex items-start gap-3 flex-grow min-w-0">
                                            <input
                                                type="checkbox"
                                                checked={selectedActivityIds.has(act.id)}
                                                onChange={() => toggleSelectActivity(act.id)}
                                                className="mt-1 rounded text-indigo-600 focus:ring-indigo-500"
                                            />
                                            <div className="flex-grow min-w-0" onClick={() => toggleExpand(act.id)}>
                                                <div className="flex items-center gap-2 text-xs text-gray-500 mb-1">
                                                    <span className="bg-gray-100 px-1.5 py-0.5 rounded text-gray-600">{act.project}</span>
                                                    <span className="font-mono">#{act.id}</span>
                                                </div>
                                                <div className="font-medium text-gray-800 text-sm truncate">{act.subject}</div>

                                                <div className={`text-xs text-gray-500 mt-2 bg-gray-50 p-2 rounded cursor-pointer whitespace-pre-wrap font-mono ${expandedIds.has(act.id) ? '' : 'line-clamp-2'}`}>
                                                    {act.notes}
                                                </div>
                                            </div>
                                        </div>
                                        <button
                                            onClick={() => onAddTask({
                                                issueId: act.id,
                                                comment: act.notes,
                                                projectName: act.project
                                            })}
                                            className="flex-shrink-0 p-2 bg-green-50 text-green-600 rounded hover:bg-green-100 transition-colors"
                                            title="加入任務列表"
                                        >
                                            <Icon name="plus" size={18} />
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    ) : (
                        !loading && <div className="text-center text-xs text-gray-400 py-4">點擊搜尋以載入當日 Redmine 活動紀錄</div>
                    )}
                </div>
            );
        };

        // --- App Component ---
        const App = () => {
            const [tasks, setTasks] = useState(() => { try { return JSON.parse(localStorage.getItem('redmine_tasks') || '[]').map(t => ({ ...t, isRunning: false })); } catch { return []; } });
            const [globalDate, setGlobalDate] = useState(() => localStorage.getItem('redmine_date') || new Date().toISOString().split('T')[0]);
            const [userName, setUserName] = useState(() => localStorage.getItem('redmine_user_v2') || '');
            const [redmineUserId, setRedmineUserId] = useState(null);
            const [workSettings, setWorkSettings] = useState(() => { try { return JSON.parse(localStorage.getItem('redmine_work_settings') || '{"startTime":"09:00", "endTime":"18:00", "breakHours": 1, "enableDinnerBreak": true}'); } catch { return { startTime: "09:00", endTime: "18:00", breakHours: 1, enableDinnerBreak: true }; } });
            const [redmineApiConfig, setRedmineApiConfig] = useState(() => {
                try {
                    const stored = JSON.parse(localStorage.getItem('redmine_api_config') || '{}');
                    return {
                        ...stored,
                        host: stored.host || 'https://igs.redmine-x.com',
                        corsProxy: stored.corsProxy || '',  // 不再預設 CORS 代理，因為使用後端代理
                        apiBaseUrl: stored.apiBaseUrl || '',  // 後端 API 基礎 URL (空字串表示同源)
                        projectsApiUrl: stored.projectsApiUrl || '/projects.json?key={密鑰}&limit=100&offset=0\n/projects.json?key={密鑰}&limit=100&offset=100\n/projects.json?key={密鑰}&limit=100&offset=200',
                        trackersApiUrl: stored.trackersApiUrl || '/projects/old_web.json?include=trackers&key={密鑰}',
                        activitiesApiUrl: stored.activitiesApiUrl || '/enumerations/time_entry_activities.json?key={密鑰}'
                    };
                } catch {
                    return {
                        host: 'https://igs.redmine-x.com',
                        corsProxy: '',
                        apiBaseUrl: '',
                        projectsApiUrl: '/projects.json?key={密鑰}&limit=100&offset=0\n/projects.json?key={密鑰}&limit=100&offset=100\n/projects.json?key={密鑰}&limit=100&offset=200',
                        trackersApiUrl: '/projects/old_web.json?include=trackers&key={密鑰}',
                        activitiesApiUrl: '/enumerations/time_entry_activities.json?key={密鑰}'
                    };
                }
            });

            const [staticData, setStaticData] = useState(() => { try { const stored = JSON.parse(localStorage.getItem('redmine_static_data') || '{}'); return { projects: stored.projects || [], trackers: stored.trackers || [], activities: stored.activities || [] }; } catch { return { projects: [], trackers: [], activities: [] }; } });

            // Shared helper to prepare URL - 使用後端代理
            const prepareFetchUrl = useCallback((rawUrl) => {
                let url = rawUrl.trim();
                let key = redmineApiConfig.apiKey ? redmineApiConfig.apiKey.trim() : '';

                // Strip placeholders
                if (key) {
                    url = url.replace(/\{(?:\s*key|api_?key|密鑰)\s*\}/gi, key);
                }

                // Extract path
                let path = url;
                if (redmineApiConfig.host) {
                    let host = redmineApiConfig.host.trim().replace(/\/$/, '');
                    if (!/^https?:\/\//i.test(host)) host = 'https://' + host;
                    if (url.startsWith(host)) {
                        path = url.substring(host.length);
                    }
                }

                if (!path.startsWith('/') && !/^https?:\/\//i.test(path)) {
                    path = '/' + path;
                }

                // If absolute URL remaining (external), try to extract path if possible or keep as is (backend might reject)
                if (/^https?:\/\//i.test(path)) {
                    try {
                        const urlObj = new URL(path);
                        path = urlObj.pathname + urlObj.search;
                    } catch (e) { }
                }

                const apiBase = redmineApiConfig.apiBaseUrl ? redmineApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                return `${apiBase}/api/proxy?path=${encodeURIComponent(path)}`;
            }, [redmineApiConfig]);

            // Gap Filler Lifted State
            const [gapFillerState, setGapFillerState] = useState({
                enabled: false,
                subject: '',
                description: '',
                doneRatio: 100
            });

            const [newTask, setNewTask] = useState(() => {
                try {
                    const saved = localStorage.getItem('redmine_new_task_draft');
                    return saved ? JSON.parse(saved) : { issueId: '', comment: '', activityId: staticData.activities[0]?.name || 'Development', projectName: '' };
                } catch {
                    return { issueId: '', comment: '', activityId: staticData.activities[0]?.name || 'Development', projectName: '' };
                }
            });
            const [roundTo, setRoundTo] = useState(0.25);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [modalConfig, setModalConfig] = useState({ isOpen: false, type: 'alert', title: '', message: '' });
            const [isLoading, setIsLoading] = useState(false);
            const [aiLoading, setAiLoading] = useState(false);
            const [batchLoading, setBatchLoading] = useState(false);
            const commentInputRef = useRef(null);

            // Sync State
            const [isServiceReady, setIsServiceReady] = useState(false);
            const [isInitialized, setIsInitialized] = useState(false);
            const [syncStatus, setSyncStatus] = useState('idle');
            const [lastSyncTime, setLastSyncTime] = useState(null);

            const stateRef = useRef({ tasks, userName, globalDate, workSettings, staticData, redmineApiConfig, newTask });
            useEffect(() => { stateRef.current = { tasks, userName, globalDate, workSettings, staticData, redmineApiConfig, newTask }; }, [tasks, userName, globalDate, workSettings, staticData, redmineApiConfig, newTask]);

            // Persistence LocalStorage
            useEffect(() => localStorage.setItem('redmine_user_v2', userName), [userName]);
            useEffect(() => { localStorage.setItem('redmine_tasks', JSON.stringify(tasks)); localStorage.setItem('redmine_date', globalDate); }, [tasks, globalDate]);
            useEffect(() => localStorage.setItem('redmine_work_settings', JSON.stringify(workSettings)), [workSettings]);
            useEffect(() => localStorage.setItem('redmine_static_data', JSON.stringify(staticData)), [staticData]);
            useEffect(() => localStorage.setItem('redmine_api_config', JSON.stringify(redmineApiConfig)), [redmineApiConfig]);

            // Persist Redmine User ID
            useEffect(() => {
                const storedId = localStorage.getItem('redmine_user_id');
                if (storedId) setRedmineUserId(parseInt(storedId));
            }, []);
            useEffect(() => {
                if (redmineUserId) localStorage.setItem('redmine_user_id', redmineUserId);
            }, [redmineUserId]);

            // [NEW] Auto-save newTask draft
            useEffect(() => {
                localStorage.setItem('redmine_new_task_draft', JSON.stringify(newTask));
            }, [newTask]);

            useEffect(() => {
                if (staticData.activities.length > 0) {
                    const activityNames = staticData.activities.map(a => a.name);
                    if (!activityNames.includes(newTask.activityId)) setNewTask(p => ({ ...p, activityId: activityNames[0] }));
                }
            }, [staticData.activities]);

            useEffect(() => {
                const interval = setInterval(() => setTasks(ts => ts.map(t => t.isRunning ? { ...t, duration: t.duration + 1000 } : t)), 1000);
                return () => clearInterval(interval);
            }, []);

            useEffect(() => {
                const checkService = () => { if (window.CloudService) { setIsServiceReady(true); return true; } return false; };
                if (!checkService()) { const i = setInterval(() => { if (checkService()) clearInterval(i); }, 200); return () => clearInterval(i); }
            }, []);

            // [NEW] Helper for API Key Hash
            const getApiKeyHash = useCallback((key) => {
                if (!key) return null;
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    const char = key.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash |= 0;
                }
                return 'key_' + Math.abs(hash).toString(36) + key.substring(0, 3) + key.substring(key.length - 3);
            }, []);

            const saveToCloud = useCallback(async (dataOverride = null) => {
                if (!window.CloudService) return;
                setSyncStatus('saving');
                try {
                    const currentState = stateRef.current;
                    const dataToSave = dataOverride || {
                        userName: currentState.userName,
                        tasks: currentState.tasks.map(t => ({ ...t, isRunning: false })),
                        globalDate: currentState.globalDate,
                        workSettings: currentState.workSettings,
                        staticData: currentState.staticData,
                        redmineApiConfig: currentState.redmineApiConfig
                    };

                    // [FIX] Only sync draft if it has content. Prevents empty draft from new browser overwriting cloud data.
                    if (currentState.newTask && currentState.newTask.comment) {
                        dataToSave.newTask = currentState.newTask;
                    }

                    const apiKey = currentState.redmineApiConfig?.apiKey;
                    const customUid = apiKey ? getApiKeyHash(apiKey) : null;

                    await window.CloudService.saveData(FIXED_ACCESS_KEY, dataToSave, customUid);
                    setSyncStatus('saved');
                    setLastSyncTime(new Date());
                } catch (e) {
                    if (e.message.includes('OFFLINE_MODE')) {
                        console.log("Offline mode");
                        setSyncStatus('offline');
                    } else if (e.message === 'PERMISSION_DENIED') {
                        setSyncStatus('permission_error');
                    } else {
                        console.error("Auto Sync Error:", e);
                        setSyncStatus('error');
                    }
                }
            }, [newTask]); // Add newTask to dependency

            useEffect(() => {
                if (!isServiceReady) return;
                const init = async () => {
                    try {
                        const apiKey = redmineApiConfig.apiKey;
                        const customUid = apiKey ? getApiKeyHash(apiKey) : null;
                        const data = await window.CloudService.loadData(FIXED_ACCESS_KEY, customUid);
                        if (data) {
                            if (data.userName) setUserName(data.userName);
                            if (data.tasks) setTasks(data.tasks.map(t => ({ ...t, isRunning: false })));
                            if (data.globalDate) setGlobalDate(data.globalDate);
                            if (data.workSettings) setWorkSettings(data.workSettings);
                            if (data.staticData) setStaticData(data.staticData);
                            if (data.redmineApiConfig) setRedmineApiConfig(data.redmineApiConfig);
                            // [FIX] Do NOT auto-restore draft on init. Only restore settings.
                            // Draft restore should be manual or explicit to differentiate "New Session" vs "Restore".

                            setLastSyncTime(new Date(data.updatedAt || Date.now()));
                            setSyncStatus('saved');
                        }
                    } catch (e) {
                        if (e.message.includes('OFFLINE_MODE')) setSyncStatus('offline');
                        else if (e.message === 'PERMISSION_DENIED') setSyncStatus('permission_error');
                    } finally { setIsInitialized(true); }
                };
                init();
            }, [isServiceReady]);

            useEffect(() => { if (!isInitialized) return; const timer = setTimeout(() => { saveToCloud(); }, 500); return () => clearTimeout(timer); }, [userName, workSettings, staticData, redmineApiConfig, saveToCloud, isInitialized]);
            // Save faster for draft changes
            useEffect(() => { if (!isInitialized) return; const timer = setTimeout(() => { saveToCloud(); }, 2000); return () => clearTimeout(timer); }, [tasks, newTask, saveToCloud, isInitialized]);

            const showRulesHelp = () => {
                setModalConfig({
                    isOpen: true,
                    title: '如何修復權限不足？',
                    confirmText: '我了解了',
                    renderContent: () => (
                        <div className="space-y-4 text-sm text-gray-600">
                            <p>您的 Firebase 專案目前的 Firestore 安全性規則設為「鎖定模式」，導致工具無法寫入資料。請依照以下步驟修復：</p>
                            <ol className="list-decimal pl-5 space-y-2">
                                <li>前往 <a href="https://console.firebase.google.com/" target="_blank" className="text-blue-600 underline">Firebase Console</a> 並選擇您的專案 (<code>redmine-diary-report</code>)。</li>
                                <li>點擊左側選單的 <strong>Firestore Database</strong>。</li>
                                <li>點擊上方的 <strong>Rules (規則)</strong> 分頁。</li>
                                <li>將編輯器中的程式碼替換為下方內容：</li>
                            </ol>
                            <div className="bg-gray-800 text-gray-200 p-3 rounded font-mono text-xs overflow-x-auto select-all">
                                {`rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}`}
                            </div>
                            <p>5. 點擊 <strong>Publish (發布)</strong> 按鈕。</p>
                            <p className="text-xs text-orange-600 mt-2">修改後約需 1~2 分鐘生效，生效後請重新整理本頁面。</p>
                        </div>
                    )
                });
            };

            const handleManualLoad = () => {
                const apiKey = redmineApiConfig.apiKey;
                // [NEW] Check API Key presence
                if (!apiKey) {
                    showAlert("提示", "請先輸入 Redmine API Key 作為您的身份識別，才能還原雲端資料。\n\n(系統使用 API Key 來查找您備份的設定)");
                    return;
                }

                showConfirm("確認還原", "這將會使用雲端上的資料覆蓋您目前的設定與任務，確定執行嗎？", async () => {
                    setSyncStatus('saving');
                    try {
                        const customUid = getApiKeyHash(apiKey);
                        const data = await window.CloudService.loadData(FIXED_ACCESS_KEY, customUid);
                        if (data) {
                            if (data.workSettings) setWorkSettings(data.workSettings);
                            if (data.staticData) setStaticData(data.staticData);
                            if (data.redmineApiConfig) setRedmineApiConfig(data.redmineApiConfig);
                            if (data.userName) setUserName(data.userName);
                            if (data.tasks) {
                                setTasks(data.tasks.map(t => ({ ...t, isRunning: false })));
                            }
                            // [NEW] Restore draft
                            if (data.newTask) setNewTask(data.newTask);

                            setLastSyncTime(new Date(data.updatedAt || Date.now()));
                            setSyncStatus('saved');
                            showAlert("還原成功", "資料已同步至最新狀態！");
                        } else {
                            showAlert("提示", "雲端尚無對應此 API Key 的資料。");
                            setSyncStatus('idle');
                        }
                    } catch (e) {
                        const msg = e.message.includes('OFFLINE_MODE') ? "目前無法連線至雲端 (離線模式)" :
                            e.message === 'PERMISSION_DENIED' ? "權限不足，請檢查 Firestore Rules" : e.message;
                        setSyncStatus(e.message === 'PERMISSION_DENIED' ? 'permission_error' : 'error');
                        showAlert("還原失敗", msg);
                    }
                });
            };

            const showConfirm = (title, message, onConfirm) => setModalConfig({ isOpen: true, type: 'confirm', title, message, onConfirm });
            const showAlert = (title, message) => setModalConfig({ isOpen: true, type: 'alert', title, message });
            const closeModal = () => setModalConfig(p => ({ ...p, isOpen: false }));

            const getDecimalHours = (ms) => { const h = ms / 3600000; return roundTo === 0 ? h.toFixed(2) : (Math.ceil(h / roundTo) * roundTo).toFixed(2); };

            // --- Updated Add Task with Duplicate Check ---
            const addTask = (e) => {
                e.preventDefault();
                if (!newTask.issueId) return;

                const duplicates = tasks.filter(t => String(t.issueId) === String(newTask.issueId));
                const isDuplicate = duplicates.length > 0;

                const processAdd = () => {
                    setTasks([...tasks, { id: Date.now(), ...newTask, duration: 0, isRunning: false }]);
                    setNewTask({ ...newTask, issueId: '', comment: '' });
                };

                if (isDuplicate) {
                    let msg = `Issue #${newTask.issueId} 已存在於列表中：\n`;
                    duplicates.forEach(d => {
                        const h = getDecimalHours(d.duration);
                        msg += `- 工時: ${h} hr`;
                        if (d.comment === newTask.comment) {
                            msg += ` (任務說明完全重複!)`;
                        }
                        msg += `\n`;
                    });
                    msg += `\n重複新增可能造成重複報工，確定要繼續嗎？`;

                    showConfirm("重複提示", msg, processAdd);
                } else {
                    processAdd();
                }
            };

            // --- Updated Batch Add with Duplicate Check ---
            const handleBatchAddTasks = (items) => {
                const defaultActivity = staticData.activities[0]?.name || 'Development';

                // Identify duplicates with details
                const duplicateDetails = [];
                items.forEach(item => {
                    const existingTasks = tasks.filter(t => String(t.issueId) === String(item.issueId));
                    if (existingTasks.length > 0) {
                        existingTasks.forEach(et => {
                            let detail = `Issue #${item.issueId} (已填工時: ${getDecimalHours(et.duration)} hr)`;
                            if (et.comment === item.comment) {
                                detail += ` [說明重複]`;
                            }
                            duplicateDetails.push(detail);
                        });
                    }
                });

                const processBatch = () => {
                    const newEntries = items.map((item, index) => ({
                        id: Date.now() + index + Math.random(),
                        issueId: item.issueId,
                        projectName: item.projectName || '',
                        comment: item.comment || '',
                        activityId: defaultActivity,
                        duration: 0,
                        isRunning: false,
                        uploaded: false
                    }));
                    setTasks(prev => [...prev, ...newEntries]);
                    showAlert("成功", `已加入 ${newEntries.length} 筆任務至列表`);
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                };

                if (duplicateDetails.length > 0) {
                    const displayList = duplicateDetails.slice(0, 10).join('\n');
                    const moreCount = duplicateDetails.length > 10 ? `\n...以及其他 ${duplicateDetails.length - 10} 筆` : '';

                    showConfirm("重複提示", `發現重複任務：\n${displayList}${moreCount}\n\n重複新增可能造成重複報工，確定要繼續嗎？`, processBatch);
                } else {
                    processBatch();
                }
            };

            const updateTask = (id, f, v) => setTasks(ts => ts.map(t => t.id === id ? { ...t, [f]: v } : t));
            const toggleTimer = (id) => setTasks(ts => ts.map(t => t.id === id ? { ...t, isRunning: !t.isRunning } : { ...t, isRunning: false }));
            const adjustTime = (id, m) => setTasks(ts => ts.map(t => t.id === id ? { ...t, duration: Math.max(0, t.duration + m * 60000) } : t));
            const updateTaskDuration = (id, newDuration) => setTasks(tasks.map(task => task.id === id ? { ...task, duration: Math.max(0, newDuration) } : task));
            const deleteTask = (id) => showConfirm("刪除", "確定刪除?", () => setTasks(ts => ts.filter(t => t.id !== id)));
            const resetUploadedStatus = (id) => setTasks(ts => ts.map(t => t.id === id ? { ...t, uploaded: false } : t));
            const resetAllUploadedStatus = () => showConfirm("重置", "確定將所有任務標記為「待上傳」嗎？", () => setTasks(ts => ts.map(t => ({ ...t, uploaded: false }))));
            const clearAll = () => showConfirm("清空", "確定清空?", () => { setTasks([]); localStorage.removeItem('redmine_tasks'); });

            const calculateExpectedHours = () => {
                const start = new Date(`2000-01-01T${workSettings.startTime}`);
                const end = new Date(`2000-01-01T${workSettings.endTime}`);
                let diff = (end - start) / 3600000;
                diff -= workSettings.breakHours;

                if (workSettings.enableDinnerBreak !== false) {
                    const dinnerStart = 18.0;
                    const dinnerEnd = 18.5;
                    const getHours = (d) => d.getHours() + d.getMinutes() / 60;
                    const startH = getHours(start);
                    const endH = getHours(end);
                    const overlapStart = Math.max(startH, dinnerStart);
                    const overlapEnd = Math.min(endH, dinnerEnd);
                    if (overlapEnd > overlapStart) diff -= (overlapEnd - overlapStart);
                }

                return Math.max(0, diff);
            };

            const totalHours = tasks.reduce((acc, curr) => acc + parseFloat(getDecimalHours(curr.duration)), 0);
            const expectedHours = calculateExpectedHours();
            const gapHours = (expectedHours - totalHours).toFixed(2);
            const isGap = parseFloat(gapHours) > 0;
            const stepMinutes = roundTo > 0 ? Math.round(roundTo * 60) : 1;

            useEffect(() => {
                if (globalDate) {
                    setGapFillerState(prev => ({ ...prev, subject: `${globalDate.replace(/-/g, '/')}組內事務` }));
                }
                if (globalDate && isGap) {
                    setGapFillerState(prev => ({ ...prev, description: `自動補足 ${globalDate} 出勤時數，共 ${gapHours} 小時。` }));
                }
            }, [globalDate, gapHours, isGap]);

            const exportCSV = () => {
                if (!userName.trim()) return showAlert("錯誤", "請先至「設定」輸入用戶名稱");
                const BOM = "\uFEFF";
                const headers = ["專案", "日期", "用戶", "活動", "議題", "回應", "小時"];
                const rows = tasks.map(t => {
                    const h = getDecimalHours(t.duration);
                    if (parseFloat(h) <= 0) return null;
                    return [`"${(t.projectName || '').replace(/"/g, '""')}"`, globalDate, userName, t.activityId, t.issueId, `"${t.comment.replace(/"/g, '""').replace(/\n/g, '\u3000')}"`, h].join(",");
                }).filter(r => r);
                if (!rows.length) return showAlert("錯誤", "無有效工時");
                const url = URL.createObjectURL(new Blob([BOM + headers.join(",") + "\r\n" + rows.join("\r\n")], { type: "text/csv;charset=utf-8;" }));
                const link = document.createElement("a"); link.href = url; link.download = `redmine_${globalDate}.csv`; link.click();
            };

            const handleWebImport = () => {
                exportCSV();
                setTimeout(() => {
                    window.open('https://igs.redmine-x.com/time_entries/imports/new', '_blank');
                    showAlert("準備匯入", "CSV 檔已下載。\n\n請在新開的 Redmine 視窗中：\n1. 選取剛下載的 CSV\n2. 連續點擊「下一頁」完成匯入");
                }, 1000);
            };

            const callAiService = async (prompt, model) => {
                const apiBase = redmineApiConfig.apiBaseUrl ? redmineApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

                try {
                    console.log(`[AI] Calling ${model}...`);
                    const response = await fetch(`${apiBase}/api/ai/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            model: model
                        }),
                        credentials: 'include',
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.error?.message || `HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
                } finally {
                    clearTimeout(timeoutId);
                }
            };

            const callAiWithRetry = async (prompt) => {
                try {
                    return await callAiService(prompt, 'gemini-1.5-flash');
                } catch (e) {
                    console.warn("gemini-1.5-flash failed, trying gemini-2.0-flash-exp", e);
                    return await callAiService(prompt, 'gemini-2.0-flash-exp');
                }
            };

            const handleAiGuessActivity = async () => {
                if (!newTask.comment) return showAlert("提示", "請先輸入任務說明，才能進行智慧判斷。");
                if (!staticData.activities || staticData.activities.length === 0) return showAlert("提示", "請先至設定頁面設定「工時-活動類型」資料。");

                // Check logged in status instead of key
                // Ideally we should check if backend has key via /api/auth/status, but for now we try call.
                // Or if we have a flag. The previous logic checked redmineApiConfig.geminiApiKey which might be empty on frontend now.
                // So we always try if we are using backend.

                setAiLoading(true);
                try {
                    const activityNames = staticData.activities.map(a => a.name);
                    const activityListStr = activityNames.join(', ');

                    const prompt = `
                        你是一個專案管理助手。請根據底下的「任務說明」，從「活動類型清單」中選出最匹配的一個。
                        規則：
                        1. 只能回傳活動類型的名稱。
                        2. 不要包含任何解釋、標點符號或 Markdown 格式。
                        3. 如果無法確定，請回傳清單中第一個選項。
                        活動類型清單：[${activityListStr}]
                        任務說明：${newTask.comment}
                    `;

                    const callGemini = async (model) => {
                        const apiBase = redmineApiConfig.apiBaseUrl ? redmineApiConfig.apiBaseUrl.trim().replace(/\/$/, '') : '';
                        const response = await fetch(`${apiBase}/api/ai/generate`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                model: model
                            }),
                            credentials: 'include'
                        });

                        if (!response.ok) {
                            const errData = await response.json().catch(() => ({}));
                            throw new Error(errData.error?.message || `HTTP ${response.status}`);
                        }
                        return response.json();
                    };

                    let data;
                    try {
                        data = await callGemini('gemini-1.5-flash');
                    } catch (e) {
                        console.warn("gemini-1.5-flash failed, trying gemini-pro", e);
                        try {
                            data = await callGemini('gemini-pro');
                        } catch (e2) {
                            throw e;
                        }
                    }

                    let aiText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
                    aiText = aiText.replace(/```/g, '').replace(/["']/g, '').trim();

                    if (aiText) {
                        let found = staticData.activities.find(a => a.name === aiText);
                        if (!found) {
                            const sortedActivities = [...staticData.activities].sort((a, b) => b.name.length - a.name.length);
                            found = sortedActivities.find(a => aiText.includes(a.name));
                        }

                        if (found) {
                            setNewTask(prev => ({ ...prev, activityId: found.name }));
                            setAiLoading(false);
                            return;
                        }
                    }
                } catch (e) {
                    console.error("AI Error:", e);
                    showAlert("AI 呼叫失敗", `無法連接後端 AI 服務或 API Key 設定錯誤：\n${e.message}\n\n系統將嘗試使用關鍵字判斷。`);
                }
                setAiLoading(false);

                // Fallback to keyword matching
                const text = newTask.comment.toLowerCase();
                const activities = staticData.activities;
                let bestMatch = null;

                for (const act of activities) {
                    if (text.includes(act.name.toLowerCase())) { bestMatch = act.name; break; }
                }

                if (!bestMatch) {
                    const mappingRules = [
                        { keywords: ['設計', 'design', 'ui', 'ux', '圖', '切版'], targets: ['設計', 'design', 'ui'] },
                        { keywords: ['開發', 'dev', 'coding', '實作', 'feature', '功能', 'api', '串接', '寫', '調整', '修正', '修', '改', 'fix'], targets: ['開發', 'develop', 'dev', '程式'] },
                        { keywords: ['測試', 'test', 'bug', '錯', '誤', '驗收', 'qa'], targets: ['測試', 'test', 'qa', '驗收', '維護'] },
                        { keywords: ['管理', 'manage', '會議', 'meeting', '討論', '溝通', 'sync', 'daily'], targets: ['管理', 'manage', '會議', '溝通'] },
                        { keywords: ['文件', 'doc', 'spec', '規格'], targets: ['文件', 'doc'] }
                    ];

                    for (const rule of mappingRules) {
                        if (rule.keywords.some(k => text.includes(k))) {
                            const targetActivity = activities.find(a => rule.targets.some(t => a.name.toLowerCase().includes(t)));
                            if (targetActivity) { bestMatch = targetActivity.name; break; }
                        }
                    }
                }

                if (bestMatch) {
                    setNewTask(prev => ({ ...prev, activityId: bestMatch }));
                } else {
                    showAlert("提示", "無法依據說明自動判斷，請手動選擇。");
                }
            };

            // Helper for safe truncation (avoids cutting surrogate pairs)
            const safeTruncate = (str, limit) => {
                if (str.length <= limit) return str;
                const sub = str.substring(0, limit);
                // If ends with high surrogate (unpaired), remove it
                if (/[\uD800-\uDBFF]$/.test(sub)) {
                    return sub.slice(0, -1);
                }
                return sub;
            };

            const handleBatchUpload = async () => {
                if (!redmineApiConfig.host || !redmineApiConfig.apiKey) return showAlert("錯誤", "請先設定 Redmine API");

                setBatchLoading(true);
                let successCount = 0;
                let failCount = 0;

                const errors = [];

                const getActivityId = (name) => {
                    if (!staticData.activities || staticData.activities.length === 0) return null;
                    const safeName = (name || '').trim().toLowerCase();
                    const found = staticData.activities.find(a => (a.name || '').trim().toLowerCase() === safeName);
                    return found ? found.id : null;
                };

                // Check activities loaded
                if (!staticData.activities || staticData.activities.length === 0) {
                    showAlert("警告", "尚未載入 Redmine 活動類型資料 (staticData)，無法將名稱轉換為 ID。\n\n請先執行「搜尋」或至設定頁面「重新擷取專案清單」。");
                    setBatchLoading(false);
                    return;
                }

                // 1. Process Gap Filler if enabled
                if (isGap && gapFillerState.enabled) {
                    if (!gapFillerState.subject || !gapFillerState.description) {
                        showAlert("錯誤", "請檢查補單的主旨與概述是否完整");
                        setBatchLoading(false);
                        return;
                    }
                    if (!redmineApiConfig.projectId || !redmineApiConfig.trackerId || !redmineApiConfig.timeActivityId) {
                        showAlert("錯誤", "請檢查補單的專案、追蹤標籤與活動類型設定是否完整");
                        setBatchLoading(false);
                        return;
                    }

                    try {
                        const issuePayload = {
                            issue: {
                                project_id: redmineApiConfig.projectId,
                                tracker_id: redmineApiConfig.trackerId,
                                subject: gapFillerState.subject,
                                description: gapFillerState.description,
                                done_ratio: gapFillerState.doneRatio
                            }
                        };

                        const issueRes = await fetch(prepareFetchUrl("/issues.json"), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(issuePayload),
                            credentials: 'include'
                        });

                        if (!issueRes.ok) throw new Error(`建立補單失敗: ${issueRes.status}`);
                        const issueData = await issueRes.json();
                        const newIssueId = issueData.issue.id;

                        // Log Time for gap
                        const timeRes = await fetch(prepareFetchUrl("/time_entries.json"), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ time_entry: { issue_id: newIssueId, hours: gapHours, activity_id: redmineApiConfig.timeActivityId, spent_on: globalDate, comments: '系統自動補單' } }),
                            credentials: 'include'
                        });

                        if (timeRes.ok) {
                            successCount++;
                        } else {
                            failCount++;
                            errors.push("補單建立成功但報工失敗");
                        }
                    } catch (e) {
                        failCount++;
                        console.error("Gap Filler Error:", e);
                        errors.push(`補單失敗: ${e.message}`);
                    }
                }

                // 2. Process Task List
                const newTasks = [...tasks];
                let skipCount = 0;  // Already uploaded
                let zeroHoursCount = 0;  // Hours <= 0

                for (let i = 0; i < newTasks.length; i++) {
                    const task = newTasks[i];
                    const hours = parseFloat(getDecimalHours(task.duration));

                    console.log(`[BatchUpload] Processing task #${task.issueId}: uploaded=${task.uploaded}, hours=${hours}, activityId=${task.activityId}`);

                    if (task.uploaded) {
                        console.log(`[BatchUpload] Skipping #${task.issueId} - Already uploaded`);
                        skipCount++;
                        continue;
                    }
                    if (hours <= 0) {
                        console.log(`[BatchUpload] Skipping #${task.issueId} - Hours <= 0`);
                        zeroHoursCount++;
                        continue;
                    }

                    const activityId = getActivityId(task.activityId);
                    if (!activityId) {
                        console.warn(`[BatchUpload] Skipping task #${task.issueId}: Activity ID not found for '${task.activityId}'`);
                        errors.push(`Issue #${task.issueId}: 找不到活動 '${task.activityId}' 的 ID`);
                        failCount++;
                        continue;
                    }

                    try {
                        let finalComment = task.comment.replace(/\n/g, '\u3000');

                        // AI Summarization for long comments
                        if (finalComment.length > 255) {
                            console.log(`[BatchUpload] Task #${task.issueId} comment too long (${finalComment.length}), summarizing...`);
                            try {
                                const prompt = `請將以下工作內容摘要成繁體中文，限制 200 字以內，不要包含標點符號外的格式。\n\n${finalComment}`;
                                const summary = await callAiWithRetry(prompt);
                                if (summary) {
                                    finalComment = safeTruncate(summary.replace(/\n/g, '\u3000'), 255);
                                    console.log(`[BatchUpload] Summarized to: ${finalComment}`);
                                    // Update task comment in UI
                                    newTasks[i] = { ...newTasks[i], comment: finalComment };
                                } else {
                                    // AI returned empty string?
                                    console.warn(`[BatchUpload] Task #${task.issueId} AI summary empty, falling back to truncation.`);
                                    finalComment = safeTruncate(finalComment.replace(/\s+/g, ' '), 255);
                                    newTasks[i] = { ...newTasks[i], comment: finalComment };
                                }
                            } catch (e) {
                                console.error(`[BatchUpload] Task #${task.issueId} AI Summarization failed:`, e);
                                errors.push(`Issue #${task.issueId} (AI Warning): ${e.message}`); // Show AI error in report
                                finalComment = safeTruncate(finalComment.replace(/\s+/g, ' '), 255);
                                newTasks[i] = { ...newTasks[i], comment: finalComment };
                            }
                        }

                        const payload = {
                            time_entry: {
                                issue_id: parseInt(task.issueId),
                                hours: hours,
                                activity_id: activityId,
                                comments: finalComment,
                                spent_on: globalDate
                            }
                        };

                        const res = await fetch(prepareFetchUrl("/time_entries.json"), {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                            credentials: 'include'
                        });

                        if (res.ok) {
                            newTasks[i] = { ...task, uploaded: true };
                            successCount++;
                        } else {
                            failCount++;
                            const errData = await res.json().catch(() => ({}));
                            const errMsg = errData.errors ? JSON.stringify(errData.errors) : res.statusText;
                            console.error(`Upload failed for #${task.issueId}`, res.status, errMsg);
                            errors.push(`Issue #${task.issueId}: ${errMsg} (${res.status})`);
                        }
                    } catch (e) {
                        failCount++;
                        console.error(e);
                        errors.push(`Issue #${task.issueId}: ${e.message}`);
                    }
                }

                setTasks(newTasks);
                setBatchLoading(false);
                saveToCloud({ tasks: newTasks });

                let resultMsg = `✅ 成功上傳: ${successCount} 筆`;
                if (skipCount > 0) resultMsg += `\n⏭️ 已上傳跳過: ${skipCount} 筆`;
                if (zeroHoursCount > 0) resultMsg += `\n⚠️ 工時為零跳過: ${zeroHoursCount} 筆`;
                if (failCount > 0) resultMsg += `\n❌ 失敗: ${failCount} 筆`;
                if (errors.length > 0) {
                    resultMsg += "\n\n錯誤詳情:\n" + errors.slice(0, 5).join("\n") + (errors.length > 5 ? "\n..." : "");
                }
                showAlert("上傳結果", resultMsg);
            };

            const handleAddFromHistory = (data) => {
                setNewTask(prev => ({
                    ...prev,
                    issueId: data.issueId,
                    projectName: data.projectName,
                    comment: data.comment
                }));
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            return (
                <div className="min-h-screen pb-10 relative">
                    <Modal config={modalConfig} onClose={closeModal} />
                    <SettingsModal
                        isOpen={isSettingsOpen}
                        onClose={() => setIsSettingsOpen(false)}
                        options={[]}
                        setOptions={() => { }}
                        workSettings={workSettings}
                        setWorkSettings={setWorkSettings}
                        staticData={staticData}
                        setStaticData={setStaticData}
                        redmineApiConfig={redmineApiConfig}
                        setRedmineApiConfig={setRedmineApiConfig}
                        userName={userName}
                        setUserName={setUserName}
                        setRedmineUserId={setRedmineUserId}
                        redmineUserId={redmineUserId}
                        syncStatus={syncStatus}
                        lastSyncTime={lastSyncTime}
                        onManualLoad={handleManualLoad}
                        onManualSave={saveToCloud}
                        showAlert={showAlert}
                        onShowRulesHelp={showRulesHelp}
                    />

                    {/* ... (Header) ... */}
                    <div className="bg-white shadow-sm sticky top-0 z-10">
                        <div className="max-w-4xl mx-auto px-4 py-4 flex flex-col sm:flex-row justify-between items-center gap-4">
                            <div className="flex items-center gap-2 w-full sm:w-auto">
                                <div className="p-2 bg-red-700 text-white rounded-lg"><Icon name="clock" /></div>
                                <h1 className="text-xl font-bold text-gray-800 mr-2">Redmine 工時助手</h1>

                                {/* Sync Status Indicator */}
                                <div className="flex items-center gap-1 text-xs" title={`雲端同步狀態: ${syncStatus === 'saved' ? '已儲存' : syncStatus === 'saving' ? '儲存中...' : syncStatus === 'offline' ? '暫時離線 (資料存於本地)' : syncStatus === 'permission_error' ? '權限錯誤 (無法寫入)' : syncStatus === 'error' ? '錯誤' : '等待中'}`}>
                                    {syncStatus === 'saving' ? (
                                        <Icon name="loader-2" size={16} className="text-blue-500 animate-spin" />
                                    ) : syncStatus === 'saved' ? (
                                        <Icon name="cloud" size={16} className="text-green-500" />
                                    ) : syncStatus === 'offline' ? (
                                        <Icon name="cloud-off" size={16} className="text-yellow-500" />
                                    ) : syncStatus === 'permission_error' ? (
                                        <Icon name="shield-alert" size={16} className="text-red-600" />
                                    ) : syncStatus === 'error' ? (
                                        <Icon name="alert-circle" size={16} className="text-red-500" />
                                    ) : (
                                        <Icon name="cloud" size={16} className="text-gray-300" />
                                    )}
                                </div>

                                <button onClick={() => setIsSettingsOpen(true)} className="ml-2 p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition-colors" title="設定"><Icon name="settings" size={20} /></button>
                            </div>
                            <div className="flex items-center gap-4 w-full sm:w-auto justify-between sm:justify-end">
                                <div className="text-right">
                                    <div className="text-xs text-gray-500">日期</div>
                                    <input type="date" value={globalDate} onChange={e => setGlobalDate(e.target.value)} className="font-mono bg-transparent border-b border-gray-300 focus:border-red-500 outline-none" />
                                </div>
                                <div className="text-right pl-4 border-l">
                                    <div className="text-xs text-gray-500">預計下班</div>
                                    <input type="time" value={workSettings.endTime} onChange={e => setWorkSettings({ ...workSettings, endTime: e.target.value })} className="font-mono bg-transparent border-b border-gray-300 focus:border-red-500 outline-none w-36" />
                                </div>
                                <div className="text-right pl-4 border-l">
                                    <div className="text-xs text-gray-500">目標 {expectedHours.toFixed(1)} / 已記 {totalHours.toFixed(2)}</div>
                                    <div className={`text-2xl font-bold font-mono ${isGap ? 'text-orange-500' : 'text-green-600'}`}>{isGap ? `-${gapHours}` : 'OK'} <span className="text-sm text-gray-400">hr</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="max-w-4xl mx-auto px-4 mt-6">

                        <DailyActivityPanel
                            date={globalDate}
                            redmineApiConfig={redmineApiConfig}
                            redmineUserId={redmineUserId}
                            onAddTask={handleAddFromHistory}
                            onBatchAdd={handleBatchAddTasks} // Pass batch handler
                            showAlert={showAlert}
                            staticData={staticData}
                            localUserName={userName}
                            prepareFetchUrl={prepareFetchUrl}
                        />

                        {/* Control Panel */}
                        <div className="bg-white p-6 rounded-xl shadow-sm mb-6">
                            <form onSubmit={addTask} className="flex flex-col gap-4">
                                {/* Row 1: ID, Project, Activity */}
                                <div className="flex flex-col md:flex-row gap-4">
                                    <div className="flex-none w-full md:w-24">
                                        <label className="text-xs text-gray-500 mb-1 block">Issue Id #</label>
                                        <input
                                            type="number"
                                            placeholder="#"
                                            className="w-full bg-gray-50 border border-gray-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none"
                                            value={newTask.issueId}
                                            onChange={e => setNewTask({ ...newTask, issueId: e.target.value })}
                                            required
                                        />
                                    </div>
                                    <div className="flex-grow w-full min-w-0">
                                        <label className="text-xs text-gray-500 mb-1 block">專案 (選填)</label>
                                        <input
                                            type="text"
                                            placeholder="專案名稱"
                                            className="w-full bg-gray-50 border border-gray-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none"
                                            value={newTask.projectName}
                                            onChange={e => setNewTask({ ...newTask, projectName: e.target.value })}
                                        />
                                    </div>
                                    <div className="flex-none w-full md:w-40">
                                        <label className="text-xs text-gray-500 mb-1 block">活動類型</label>
                                        <div className="flex gap-1">
                                            {staticData.activities.length > 0 ? (
                                                <select className="flex-grow bg-gray-50 border border-gray-200 rounded-lg px-2 py-2 focus:outline-none focus:ring-2 focus:ring-red-500 text-sm" value={newTask.activityId} onChange={e => setNewTask({ ...newTask, activityId: e.target.value })}>
                                                    {staticData.activities.map(opt => <option key={opt.id} value={opt.name}>{opt.name}</option>)}
                                                </select>
                                            ) : (
                                                <div className="flex-grow text-xs text-gray-400 border border-dashed rounded px-2 py-2 text-center bg-gray-50">設定</div>
                                            )}
                                            {/* AI Button */}
                                            <button
                                                type="button"
                                                onClick={handleAiGuessActivity}
                                                className="flex-none p-2 bg-purple-100 border border-purple-200 rounded-lg text-purple-600 hover:bg-purple-200 transition-colors"
                                                title="AI 智能推測"
                                            >
                                                {aiLoading ? <Icon name="loader-2" className="animate-spin" size={18} /> : <Icon name="sparkles" size={18} />}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                {/* Row 2: Comment, Button */}
                                <div className="flex flex-col md:flex-row gap-4 items-end">
                                    <div className="flex-grow w-full">
                                        <label className="text-xs text-gray-500 mb-1 block">任務說明</label>
                                        <textarea placeholder="說明..." className="w-full bg-gray-50 border border-gray-200 rounded-lg px-3 py-2 focus:ring-2 focus:ring-red-500 focus:outline-none resize-y overflow-hidden leading-normal" rows={1} value={newTask.comment} onChange={e => { setNewTask({ ...newTask, comment: e.target.value }); e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; }} style={{ minHeight: '42px' }} />
                                    </div>
                                    <div className="flex-none w-full md:w-auto">
                                        <button type="submit" className="w-full bg-gray-800 hover:bg-gray-700 text-white px-6 py-2.5 rounded-lg flex items-center justify-center gap-2 whitespace-nowrap h-[42px]"><Icon name="plus" size={18} /> 新增任務</button>
                                    </div>
                                </div>
                            </form>
                            <div className="mt-4 pt-4 border-t flex items-center justify-between text-sm text-gray-500">
                                <div className="flex items-center gap-2"><span>進位單位：</span><select value={roundTo} onChange={e => setRoundTo(parseFloat(e.target.value))} className="bg-gray-100 border-none rounded px-2 py-1"><option value={0}>不進位</option><option value={0.1}>0.1 小時 (6分)</option><option value={0.25}>0.25 小時 (15分)</option><option value={0.5}>0.5 小時 (30分)</option></select></div>
                            </div>
                        </div>

                        {/* Task List */}
                        <div className="space-y-3">
                            {tasks.length === 0 && <div className="text-center py-12 text-gray-400 bg-white rounded-xl border-2 border-dashed border-gray-200"><Icon name="coffee" size={48} className="mx-auto mb-3 opacity-50" /><p>輸入 Issue ID 開始工作吧！</p></div>}
                            {tasks.map(task => (
                                <div key={task.id} className={`timer-card bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex flex-col sm:flex-row items-center justify-between gap-4 ${task.isRunning ? 'active' : ''}`}>
                                    <div className="flex items-center gap-4 flex-grow w-full sm:w-auto">
                                        <div className={`p-3 rounded-full flex-shrink-0 ${task.isRunning ? 'bg-green-100 text-green-600' : 'bg-gray-100 text-gray-400'}`}>{task.isRunning ? <Icon name="play" className="fill-current" /> : <Icon name="pause" />}</div>
                                        <div className="flex-grow min-w-0">
                                            <div className="flex items-center gap-2 flex-wrap mb-1">
                                                <div className="flex items-center bg-gray-100 rounded px-1.5 py-0.5 hover:bg-gray-200 group focus-within:ring-1 focus-within:ring-red-500">
                                                    <span className="text-xs text-gray-500 font-bold mr-0.5">#</span>
                                                    <input type="text" value={task.issueId} onChange={e => updateTask(task.id, 'issueId', e.target.value)} className="bg-transparent border-none outline-none text-xs font-bold text-gray-700 w-14 font-mono" />
                                                </div>
                                                <input type="text" value={task.projectName} onChange={e => updateTask(task.id, 'projectName', e.target.value)} placeholder="專案..." className="text-xs bg-blue-50 text-blue-600 px-2 py-0.5 rounded border border-blue-100 hover:border-blue-300 focus:border-blue-500 outline-none w-24 placeholder-blue-300" />
                                                {staticData.activities.length > 0 ? (
                                                    <select value={task.activityId} onChange={e => updateTask(task.id, 'activityId', e.target.value)} className="text-xs text-gray-500 border border-gray-200 hover:border-gray-400 bg-white rounded px-1 py-0.5 focus:border-red-500 outline-none max-w-[120px]">
                                                        {staticData.activities.map(opt => <option key={opt.id} value={opt.name}>{opt.name}</option>)}
                                                    </select>
                                                ) : (
                                                    <span className="text-xs text-gray-400 border border-dashed rounded px-1 py-0.5">無選項</span>
                                                )}
                                            </div>
                                            <TaskTextarea value={task.comment} onChange={e => updateTask(task.id, 'comment', e.target.value)} />
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-4 w-full sm:w-auto justify-between sm:justify-end">
                                        <div className="text-right">
                                            <TimeInput duration={task.duration} isRunning={task.isRunning} onUpdate={d => updateTaskDuration(task.id, d)} />
                                            <div className="text-xs text-gray-400 font-mono text-right mt-1">≈ {getDecimalHours(task.duration)} hr</div>
                                        </div>
                                        <div className="flex items-center gap-1">
                                            {task.uploaded ? (
                                                <button onClick={() => resetUploadedStatus(task.id)} className="p-2 text-green-500 hover:text-orange-500 hover:bg-orange-50 rounded-lg transition-colors" title="已上傳 (點擊重置)"><Icon name="check-circle" /></button>
                                            ) : (
                                                <button onClick={() => toggleTimer(task.id)} className={`p-2 rounded-lg transition-colors ${task.isRunning ? 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}>{task.isRunning ? <Icon name="pause" /> : <Icon name="play" />}</button>
                                            )}
                                        </div>
                                    </div>
                                    <div className="flex sm:flex-col gap-2 border-t sm:border-t-0 sm:border-l pt-3 sm:pt-0 sm:pl-3 w-full sm:w-auto justify-center">
                                        <div className="flex gap-2">
                                            <button onClick={() => adjustTime(task.id, stepMinutes)} className="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded text-gray-600">+{stepMinutes}m</button>
                                            <button onClick={() => adjustTime(task.id, -stepMinutes)} className="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded text-gray-600">-{stepMinutes}m</button>
                                        </div>
                                        <button onClick={() => deleteTask(task.id)} className="text-red-400 hover:text-red-600 text-sm flex items-center justify-center gap-1 mt-1"><Icon name="trash-2" size={14} />刪除</button>
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Gap Filler */}
                        {isGap && <RedmineGapFiller gapHours={gapHours} date={globalDate} showAlert={showAlert} staticData={staticData} onSuccess={() => { }} redmineApiConfig={redmineApiConfig} setRedmineApiConfig={setRedmineApiConfig} state={gapFillerState} setState={setGapFillerState} prepareFetchUrl={prepareFetchUrl} />}

                        {tasks.length > 0 && (
                            <div className="mt-8 flex flex-col sm:flex-row justify-between items-center bg-gray-800 text-white p-4 rounded-xl shadow-lg gap-4">
                                <div className="text-sm text-gray-300 hidden sm:block">準備下班了嗎？</div>
                                <div className="flex flex-wrap gap-3 w-full sm:w-auto justify-end">
                                    <button onClick={clearAll} className="px-4 py-2 text-sm text-gray-400 hover:text-white transition-colors">清空列表</button>

                                    <div className="flex gap-2 bg-gray-700 rounded-lg p-1">
                                        <button onClick={exportCSV} className="bg-transparent hover:bg-gray-600 text-white px-3 py-1.5 rounded-md text-sm flex items-center gap-2 transition-all">
                                            <Icon name="download" size={16} /> 匯出 CSV
                                        </button>
                                        <div className="w-px bg-gray-600 my-1"></div>
                                        <button onClick={handleWebImport} className="bg-transparent hover:bg-gray-600 text-white px-3 py-1.5 rounded-md text-sm flex items-center gap-2 transition-all" title="開啟 Redmine 匯入頁面 (半自動)">
                                            <Icon name="external-link" size={16} />
                                        </button>
                                    </div>

                                    <button
                                        onClick={handleBatchUpload}
                                        disabled={batchLoading}
                                        className="bg-green-600 hover:bg-green-500 text-white px-6 py-2 rounded-lg font-bold flex items-center gap-2 shadow-lg transform active:scale-95 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                                        title="直接透過 API 上傳所有工時"
                                    >
                                        {batchLoading ? <Icon name="loader-2" className="animate-spin" size={18} /> : <Icon name="upload-cloud" size={18} />}
                                        API 上傳
                                    </button>
                                </div>
                            </div>
                        )}
                        <div className="mt-8 text-center text-xs text-gray-400 pb-8">匯出的 CSV 格式包含 BOM 標頭，Excel 可直接開啟不亂碼。</div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>