<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>表格轉純文字工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
        }

        /* 確保預覽區域使用等寬字體，模擬 Windows 記事本 */
        .notepad-font {
            font-family: 'Consolas', 'Courier New', 'PMingLiU', monospace;
            white-space: pre;
            overflow-x: auto;
            line-height: 1.5;
            tab-size: 8; /* 預設 Tab 寬度為 8 */
        }

        /* 自定義 Radio Button 樣式 */
        .radio-label {
            cursor: pointer;
            user-select: none;
        }
        .radio-input:checked + span {
            background-color: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
            font-weight: 500;
        }

        /* 輸入區表格樣式 */
        #inputArea table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.5rem 0;
            font-size: 0.9em;
            border: 1px solid #d1d5db;
        }
        #inputArea th, #inputArea td {
            border: 1px solid #d1d5db;
            padding: 4px 8px;
            text-align: left;
            vertical-align: top;
        }
        #inputArea th {
            background-color: #f3f4f6;
            font-weight: 600;
        }
        #inputArea ul, #inputArea ol {
            padding-left: 20px;
            list-style-type: disc;
        }

        [contenteditable]:empty:before {
            content: attr(placeholder);
            color: #9ca3af;
            pointer-events: none;
            display: block;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- 標題列 -->
    <header class="bg-white shadow-sm border-b border-gray-200 p-4 shrink-0 z-10">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 text-white p-2 rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="M8 15h8"/></svg>
                </div>
                <h1 class="text-xl font-bold text-gray-800">表格轉純文字工具</h1>
            </div>
            <div class="text-sm text-gray-500 hidden sm:block">專為 Windows 記事本優化</div>
        </div>
    </header>

    <!-- 主內容區 -->
    <main class="flex-1 flex flex-col md:flex-row max-w-7xl mx-auto w-full p-4 gap-4 overflow-hidden">
        
        <!-- 輸入區 -->
        <div class="flex-1 flex flex-col bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
            <div class="p-3 border-b border-gray-100 bg-gray-50 flex flex-col gap-3">
                <div class="flex justify-between items-center">
                    <label class="font-semibold text-gray-700 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        輸入 (所見即所得)
                    </label>
                    <button onclick="clearInput()" class="text-xs text-red-500 hover:text-red-700 hover:bg-red-50 px-2 py-1 rounded transition">清空</button>
                </div>
                
                <!-- 對齊策略選擇 -->
                <div class="flex flex-col gap-2 text-xs bg-gray-50 p-2 rounded border border-gray-200">
                    <span class="text-gray-500 font-medium">排版策略：</span>
                    <div class="flex flex-wrap gap-2">
                        <label class="radio-label">
                            <input type="radio" name="alignMode" value="space" class="radio-input hidden" onchange="convertText()">
                            <span class="px-3 py-1.5 border border-gray-200 rounded-md transition hover:bg-white bg-white block text-center">
                                一般空白對齊<br><span class="text-[10px] text-gray-400">標準 ASCII 表格</span>
                            </span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="alignMode" value="fullwidth" class="radio-input hidden" onchange="convertText()">
                            <span class="px-3 py-1.5 border border-gray-200 rounded-md transition hover:bg-white bg-white block text-center">
                                全形空白填充<br><span class="text-[10px] text-gray-400">解決中文跑版神器</span>
                            </span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="alignMode" value="tab_layout_4" class="radio-input hidden" onchange="convertText()">
                            <span class="px-3 py-1.5 border border-gray-200 rounded-md transition hover:bg-white bg-white block text-center">
                                Tab 排版 (4字元)<br><span class="text-[10px] text-gray-400">常見無框線</span>
                            </span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="alignMode" value="tab_layout_8" checked class="radio-input hidden" onchange="convertText()">
                            <span class="px-3 py-1.5 border border-gray-200 rounded-md transition hover:bg-white bg-white block text-center">
                                Tab 排版 (8字元)<br><span class="text-[10px] text-gray-400">傳統無框線</span>
                            </span>
                        </label>
                    </div>
                    <div class="flex items-center gap-2 mt-1">
                        <input type="checkbox" id="useTabIndent" checked onchange="convertText()" class="accent-blue-600">
                        <label for="useTabIndent" class="cursor-pointer select-none">內容清單使用 Tab 縮排 (保留層級)</label>
                    </div>
                </div>
            </div>
            
            <div id="inputArea" contenteditable="true" class="flex-1 w-full p-4 overflow-auto outline-none focus:bg-blue-50/30 transition text-sm leading-relaxed font-mono" placeholder="請直接貼上表格。&#10;&#10;程式會自動保留清單層級，並轉換為 Tab 縮排。"></div>
        </div>

        <!-- 中間操作區 -->
        <div class="flex md:flex-col justify-center items-center gap-2 shrink-0">
            <button onclick="convertText()" class="group bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg hover:shadow-xl transition-all active:scale-95 flex flex-col items-center justify-center gap-1 w-full md:w-auto" title="執行轉換">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="md:rotate-90"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                <span class="text-xs font-medium md:hidden">轉換</span>
            </button>
        </div>

        <!-- 輸出區 -->
        <div class="flex-1 flex flex-col bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden relative">
            <div class="p-3 border-b border-gray-100 bg-gray-50 flex justify-between items-center">
                <label class="font-semibold text-gray-700 flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-500"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                    輸出
                </label>
                <button onclick="copyOutput()" id="copyBtn" class="flex items-center gap-1 text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-3 py-1 rounded transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    複製
                </button>
            </div>
            <textarea id="outputArea" class="notepad-font flex-1 w-full p-4 resize-none outline-none bg-[#fafafa] text-gray-800 text-sm" readonly placeholder="轉換結果..."></textarea>
            <div id="toast" class="absolute bottom-4 right-4 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg text-sm opacity-0 transition-opacity duration-300 pointer-events-none">已複製</div>
        </div>
    </main>

    <script>
        // 計算字串的「視覺寬度」
        function getVisualLength(str, tabSize = 4) {
            let len = 0;
            for (let i = 0; i < str.length; i++) {
                const code = str.charCodeAt(i);
                if (code === 9) { // Tab
                    // 模擬 Tab 行為：跳到下一個 Tab Stop
                    len = (Math.floor(len / tabSize) + 1) * tabSize;
                } else if (code > 255) {
                    len += 2;
                } else {
                    len += 1;
                }
            }
            return len;
        }

        // 使用指定字元填充 (Space/Fullwidth 模式用)
        function padString(str, width, padChar = ' ') {
            const visualLen = getVisualLength(str, 4); 
            const padding = Math.max(0, width - visualLen);
            if (padChar === '\u3000') {
                const count = Math.ceil(padding / 2);
                return str + padChar.repeat(count);
            }
            return str + padChar.repeat(padding);
        }

        function extractNodeText(node, indent = 0) {
            if (node.nodeType === Node.TEXT_NODE) {
                return node.textContent.replace(/\s+/g, ' ');
            }
            
            if (node.nodeType !== Node.ELEMENT_NODE) return '';

            let text = '';
            const tagName = node.tagName;
            const useTabIndent = document.getElementById('useTabIndent').checked;
            const indentChar = useTabIndent ? '\t' : '  ';

            if (tagName === 'BR') return '\n';
            if (tagName === 'LI') {
                text += '\n' + indentChar.repeat(indent) + (useTabIndent ? '• ' : '- '); 
            }
            if (tagName === 'P' || tagName === 'DIV') {
                if (node.previousSibling) text += '\n'; 
            }

            const childIndent = (tagName === 'UL' || tagName === 'OL') ? indent + 1 : indent;
            for (let child of node.childNodes) {
                text += extractNodeText(child, childIndent);
            }

            return text;
        }

        function convertText() {
            const inputDiv = document.getElementById('inputArea');
            const alignMode = document.querySelector('input[name="alignMode"]:checked').value;
            
            // 同步調整預覽區的 tab-size
            const outputArea = document.getElementById('outputArea');
            if (alignMode === 'tab_layout_8') {
                outputArea.style.tabSize = '8';
            } else {
                outputArea.style.tabSize = '4';
            }
            
            const tables = inputDiv.querySelectorAll('table');
            
            if (tables.length > 0) {
                processDomTables(inputDiv, alignMode);
            } else {
                const rawText = inputDiv.innerText;
                processPlainText(rawText, alignMode);
            }
        }

        function processDomTables(sourceDiv, alignMode) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = sourceDiv.innerHTML;
            const tables = tempDiv.querySelectorAll('table');
            
            tables.forEach(table => {
                let rowsData = [];
                for (let i = 0; i < table.rows.length; i++) {
                    const tr = table.rows[i];
                    let rowCells = [];
                    for (let j = 0; j < tr.cells.length; j++) {
                        const cell = tr.cells[j];
                        let cellText = extractNodeText(cell);
                        cellText = cellText.replace(/^\n+/, '').trimEnd();
                        
                        // 儲存文字與 Colspan 資訊
                        rowCells.push({
                            text: cellText,
                            colSpan: cell.colSpan || 1
                        });
                    }
                    rowsData.push(rowCells);
                }

                if (rowsData.length > 0) {
                    const asciiTable = generateAsciiTable(rowsData, alignMode);
                    const textNode = document.createTextNode('\n' + asciiTable + '\n');
                    table.parentNode.replaceChild(textNode, table);
                }
            });

            document.getElementById('outputArea').value = tempDiv.innerText;
        }

        function processPlainText(text, alignMode) {
            if (!text.trim()) return;
            const lines = text.split('\n');
            let rows = [];
            
            const firstLine = lines.find(l => l.trim().length > 0);
            const isTsv = firstLine && firstLine.includes('\t');
            
            lines.forEach(line => {
                if (!line.trim()) return;
                let cells = [];
                if (isTsv) {
                    cells = line.split('\t').map(c => c.trim());
                } else if (line.includes('|')) {
                    let content = line.trim();
                    if (content.startsWith('|')) content = content.substring(1);
                    if (content.endsWith('|')) content = content.substring(0, content.length - 1);
                    if (content.replace(/[\-\:\s\|]/g, '') === '') return;
                    cells = content.split('|').map(c => c.trim());
                } else {
                    cells = [line.trim()];
                }
                
                // 純文字模式下預設 Colspan 為 1
                rows.push(cells.map(c => ({ text: c, colSpan: 1 })));
            });

            const result = generateAsciiTable(rows, alignMode);
            document.getElementById('outputArea').value = result;
        }

        function generateAsciiTable(rows, alignMode) {
            if (!rows || rows.length === 0) return '';

            // 判斷 Tab 尺寸
            let currentTabSize = 4;
            if (alignMode === 'tab_layout_8') currentTabSize = 8;
            
            // --- 1. 收集所有欄位的寬度 ---
            let colWidthsData = []; // 二維陣列，存每一欄的所有寬度
            rows.forEach(row => {
                row.forEach((cell, index) => {
                    if (cell.colSpan > 1) return; // 跳過跨欄

                    const lines = cell.text.split('\n');
                    lines.forEach(line => {
                        const len = getVisualLength(line, currentTabSize);
                        if (!colWidthsData[index]) colWidthsData[index] = [];
                        colWidthsData[index].push(len);
                    });
                });
            });

            // --- 2. 決定每一欄的「最大寬度」 (恢復使用 Math.max) ---
            let colWidths = colWidthsData.map(widths => {
                // 不論是否為 Tab 模式，皆使用最大寬度以確保對齊最長行
                return Math.max(...widths);
            });

            if (alignMode === 'fullwidth') {
                colWidths = colWidths.map(w => w % 2 !== 0 ? w + 1 : w);
            }

            // --- 3. Tab Layout 特殊處理 ---
            if (alignMode === 'tab_layout_4' || alignMode === 'tab_layout_8') {
                
                const colTabStops = colWidths.map(w => {
                    // 計算對齊目標：大於等於最大寬度的下一個 Tab Stop
                    return (Math.floor(w / currentTabSize) + 1) * currentTabSize;
                });

                let result = [];

                rows.forEach((row, rowIndex) => {
                    const cellLines = row.map(cell => cell.text.split('\n'));
                    const maxLines = Math.max(...cellLines.map(lines => lines.length));

                    for (let lineIdx = 0; lineIdx < maxLines; lineIdx++) {
                        let lineStr = ''; 
                        
                        for (let i = 0; i < row.length; i++) {
                            const cellObj = row[i];
                            const content = (cellLines[i] && cellLines[i][lineIdx]) ? cellLines[i][lineIdx] : '';
                            
                            lineStr += content;
                            
                            // 補 Tab 邏輯
                            if (i < row.length - 1) {
                                if (cellObj.colSpan > 1) {
                                    lineStr += '\t';
                                } else {
                                    let currentSegment = content;
                                    let currentLen = 0;
                                    
                                    // 計算目前片段的「視覺長度」
                                    for (let charIdx = 0; charIdx < currentSegment.length; charIdx++) {
                                        const cCode = currentSegment.charCodeAt(charIdx);
                                        if (cCode === 9) { 
                                            currentLen = (Math.floor(currentLen / currentTabSize) + 1) * currentTabSize;
                                        } else if (cCode > 255) {
                                            currentLen += 2;
                                        } else {
                                            currentLen += 1;
                                        }
                                    }
                                    
                                    const targetLen = colTabStops[i] || 0;
                                    
                                    // 若內容本身已經超過或等於目標寬度，至少補 1 個 Tab
                                    if (currentLen >= targetLen) {
                                        lineStr += '\t';
                                    } else {
                                        // 正常情況，補到目標對齊點
                                        do {
                                            lineStr += '\t';
                                            currentLen = (Math.floor(currentLen / currentTabSize) + 1) * currentTabSize;
                                        } while (currentLen < targetLen);
                                    }
                                }
                            }
                        }
                        result.push(lineStr);
                    }
                });

                return result.join('\n');
            }

            // --- 4. Space/Fullwidth Layout (原有的空白填充邏輯) ---
            const buildSeparator = (char, intersection) => {
                let parts = colWidths.map(w => char.repeat(w + 2));
                return intersection + parts.join(intersection) + intersection;
            };

            const borderLine = buildSeparator('-', '+');
            let result = [];
            result.push(borderLine);

            rows.forEach((row, rowIndex) => {
                const cellLines = row.map(cell => cell.text.split('\n'));
                const maxLines = Math.max(...cellLines.map(lines => lines.length));

                for (let lineIdx = 0; lineIdx < maxLines; lineIdx++) {
                    let lineStr = '|';
                    for (let i = 0; i < colWidths.length; i++) {
                        const content = (cellLines[i] && cellLines[i][lineIdx]) ? cellLines[i][lineIdx] : '';
                        let padChar = ' ';
                        if (alignMode === 'fullwidth') padChar = '\u3000'; 
                        
                        const paddedContent = padString(content, colWidths[i], padChar);
                        lineStr += ' ' + paddedContent + ' |'; 
                    }
                    result.push(lineStr);
                }
                
                if (rowIndex === 0 && rows.length > 1) {
                    result.push(borderLine);
                }
            });

            result.push(borderLine);
            return result.join('\n');
        }

        function clearInput() {
            document.getElementById('inputArea').innerHTML = '';
            document.getElementById('outputArea').value = '';
        }

        function copyOutput() {
            const output = document.getElementById('outputArea');
            output.select();
            document.execCommand('copy');
            const toast = document.getElementById('toast');
            toast.style.opacity = '1';
            setTimeout(() => { toast.style.opacity = '0'; }, 2000);
        }

        window.onload = function() {
            document.getElementById('inputArea').focus();
        }
    </script>
</body>
</html>
